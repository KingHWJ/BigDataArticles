<html>
<head>
<title></title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0,viewport-fit=cover">
<style>
*{margin:0;padding:0}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;line-height:1.6}img{z-index:999;position:relative;max-width:100%;margin:10px 0;}body{letter-spacing:.034em}h1,h2,h3,h4,h5,h6{font-weight:400;font-size:16px}a{color:#576b95;text-decoration:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}td,th{word-wrap:break-word;padding:5px 10px;border:1px solid #DDD;}table{margin-bottom:10px;border-collapse:collapse;display:table;width:100%!important;}.appmsg_skin_default .rich_media_area_primary{background-color:#fff}.appmsg_skin_default .rich_media_area_primary .weui-loadmore_line .weui-loadmore__tips{background-color:#fff}.rich_media_area_primary{padding:20px 16px 12px;background-color:#fafafa}@media (max-width:375px){.rich_media_area_primary{padding:20px 60px 15px 60px}.rich_media_area_extra{padding:0 60px 21px 60px}}@media (min-width:1024px){.rich_media_area_primary_inner,.rich_media_area_extra_inner,body{max-width:677px;margin-left:auto;margin-right:auto}.rich_media_area_primary{padding-top:32px}}.rich_media{padding:20px;overflow:hidden;}.appmsg_skin_default .rich_media_area_primary{background-color:#fff}.appmsg_skin_default .rich_media_area_primary .weui-loadmore_line .weui-loadmore__tips{background-color:#fff}@media screen and (min-width:1024px){.rich_media_area_primary_inner,.rich_media_area_extra_inner{max-width:677px;margin-left:auto;margin-right:auto}.rich_media_area_primary{padding-top:32px}}.rich_media_content{overflow:hidden;color:#333;font-size:17px;word-wrap:break-word;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;text-align:justify;position:relative;z-index:0}.rich_media_content *{max-width:100%!important;box-sizing:border-box!important;-webkit-box-sizing:border-box!important;word-wrap:break-word!important}.rich_media_content p{clear:both;min-height:1em}.rich_media_content em{font-style:italic}.rich_media_content fieldset{min-width:0}.rich_media_content .list-paddingleft-1,.rich_media_content .list-paddingleft-2,.rich_media_content .list-paddingleft-3{padding-left:2.2em}.rich_media_content .list-paddingleft-1 .list-paddingleft-2,.rich_media_content .list-paddingleft-2 .list-paddingleft-2,.rich_media_content .list-paddingleft-3 .list-paddingleft-2{padding-left:30px}.rich_media_content .list-paddingleft-1{padding-left:1.2em}.rich_media_content .list-paddingleft-3{padding-left:3.2em}.rich_media_content .code-snippet,.rich_media_content .code-snippet__fix{max-width:1000%!important}.rich_media_content .code-snippet *,.rich_media_content .code-snippet__fix *{max-width:1000%!important}.rich_media_title{font-size:22px;line-height:1.4;margin-bottom:13px;padding-bottom:13px;border-bottom:1px solid #e7e7eb;}@supports(-webkit-overflow-scrolling:touch){.rich_media_title{font-weight:700}}.rich_media_meta{display:inline-block;vertical-align:middle;padding:0 0 10px 0;font-size:15px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.rich_media_meta.icon_appmsg_tag{margin-right:0px}.rich_media_meta.meta_tag_text{margin-right:0}.rich_media_meta_list em{font-style:normal}.rich_media_meta_text{color:#a5a5a5;}p{margin:0;}.msgBox{margin-top:20px;padding-top:20px;padding-left:50px;overflow:hidden;border-top:2px dashed #09a2ff;}.msg{padding-top:7px;clear:both;}.msgBody{float:right;width:100%;margin-left:55px;padding-bottom:15px;border-bottom:1px dashed #e0e0e0;}.userHeadImg{float:left;margin-left:-50px;}.userHeadImg img{width:40px;height:40px;margin-right:10px;border-radius:3px;}.userName{color:#888888;line-height:24px;font-size:14px;margin:5px 0 5px 0;height:24px;}.replyBody,.autherBody{color:#565656;font-size:15px;}.replyIcon{border-left:4px solid #33ab01;margin-right:5px;}.ad{text-decoration:none;color:#d6d4d4;font-size:12px;}.msgBodyReply{padding-top:5px;}.userName span{float:right;color:#afafaf;font-size:14px;}code{text-align:left;font-size:14px;display:block;white-space:pre;display:-webkit-box;display:-webkit-flex;display:flex;position:relative;}.code-snippet__fix{font-size:14px;margin:10px 0;display:block;color:#333;position:relative;background-color:rgba(0,0,0,0.03);border:1px solid #f0f0f0;border-radius:2px;display:-webkit-box;display:-webkit-flex;display:flex;padding-left:25px;line-height:26px}.code-snippet__fix code{text-align:left;font-size:14px;display:block;white-space:pre;display:-webkit-box;display:-webkit-flex;display:flex;position:relative;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace}.code-snippet__comment,.code-snippet__quote{color:#afafaf;font-style:italic}.code-snippet__keyword,.code-snippet__selector-tag,.code-snippet__subst{color:#ca7d37}.code-snippet__number,.code-snippet__literal,.code-snippet__variable,.code-snippet__template-variable,.code-snippet__tag .code-snippet__attr{color:#0e9ce5}.code-snippet__string,.code-snippet__doctag{color:#d14}.code-snippet__title,.code-snippet__section,.code-snippet__selector-id{color:#d14}.code-snippet__subst{font-weight:normal}.code-snippet__type,.code-snippet__class .code-snippet__title{color:#0e9ce5}.code-snippet__tag,.code-snippet__name,.code-snippet__attribute{color:#0e9ce5;font-weight:normal}.code-snippet__regexp,.code-snippet__link{color:#ca7d37}.code-snippet__symbol,.code-snippet__bullet{color:#d14}.code-snippet__built_in,.code-snippet__builtin-name{color:#ca7d37}.code-snippet__meta{color:#afafaf}.code-snippet__deletion{background:#fdd}.code-snippet__addition{background:#dfd}.code-snippet__emphasis{font-style:italic}.code-snippet__strong{font-weight:bold}.account_avatar{width:40px;height:40px;padding:0;}.account_info{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-align:center;-webkit-align-items:center;padding:20px 0;align-items:center}.flex_bd{padding-left:14px;}.account_nickname{display:inline-block;vertical-align:middle;line-height:1.2;color:#576b95;font-size:14px}.account_desc{overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;color:rgba(0,0,0,0.3);font-size:14px;line-height:1.2;padding-top:.4em}.msg_source_url{text-align:left;word-break:break-all;margin-top:20px;}.msg_source_url a{padding-right:10px;}.msg_source_url .url_text{color:#a8a8a8;}.video-desc{font-size:14px;margin-top:15px;color:#6c6c6c;}.msg_source_url{text-align:left;}.original_primary_card_tips{color:rgba(0,0,0,0.3);line-height:1.4;font-size:15px;}.weui-flex__item{margin-bottom:20px;padding:20px 16px;margin-top:16px;line-height:1.4;align-items:center;background-color:#f7f7f7;border-radius:8px;position:relative;}.original_primary_desc{color:rgba(0,0,0,0.5);font-size:14px;padding-top:4px;width:auto;overflow:hidden;text-overflow:ellipsis;}.msgBodyReplyList{border-top:1px solid #e1e1e1;margin-top:10px;}.msgBodyReplyListTop{border-top:0;}.reply_like_num{float:right;font-size:14px;color:#c7c7c7;}.msgData{margin-top:20px;color:#626262;}.msgData span{font-size:14px;padding-right:15px;}.msgData .likes{float:right;padding-right:0;}.js_text_content p{font-size:18px;}.rich_media_meta_link{font-size:15px;}blockquote {padding-left: 10px;border-left: 3px solid #dbdbdb;color: rgba(0,0,0,0.5);font-size: 15px;padding-top: 4px;margin: 1em 0;}.video_iframe{width:500px;height:400px;}.blockquote_info{color:#b5b5b5;margin-top:10px;}#copyright_logo{color:#bdbdbd;}.rich_media_meta_list{margin-bottom:10px;}.reprint{background:#efefef;border-radius:5px;padding:8px;color:#1f1f1f;}.reprint a{word-break:break-all;}.topic{color:#8e8e8e;background:#f7f7f7;border-radius:5px;padding:10px 8px;}.topic a{padding-right:5px;}.topic p{margin-bottom:5px;}
</style>
<link href="https://www.juyifx.cn/config/css/wxArticle.css" rel="stylesheet"/>
</head><script>
var data={"mp":"数据治理体系","title":"实时数仓案例集合","time":"2023-02-22 07:42:15","timeStamp":"1677022935"};
</script>
<body>
<div class="rich_media"><h1 class="rich_media_title" id="activity-name"><a href="http://mp.weixin.qq.com/s?__biz=MzA3NjIzNjMwOA==&mid=2247493661&idx=1&sn=d449dce7e641f6386cb07f391436ba84&chksm=9f66fb66a8117270613af0d2202cec31449c6191cce289c1a0304c0961ef90126b2676403176#rd" target="_blank">实时数仓案例集合</a></h1><div id="meta_content" class="rich_media_meta_list"><span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);" class="wx_tap_link js_wx_tap_highlight weui-wa-hotarea" id="js_name">数据治理体系&nbsp;&nbsp;</a></span><em id="publish_time" class="rich_media_meta rich_media_meta_text">2023-02-22 07:42:15</em></div><content><section data-mpa-powered-by="yiban.io"><mp-common-profile class="custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-weuitheme="light" data-id="MzA3NjIzNjMwOA==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhzia07WkYkDfaRxHUiaDaNc5x3xTNO1RlNBRhPnxpEzoemhsn7ofat4pVwVgOktaveEtu6IKzzLONQQ/0?wx_fmt=png" data-nickname="数据治理体系" data-alias="DGsystem" data-signature="持续完善数据治理实战体系，数据仓库、标签、数字体系，实现业务数字化，数字资产化，资产业务化，资产资本化；回归业务场景的数字化案例才最具参考价值，最容易理解和借鉴的。" data-from="0" data-weui-theme="light"></mp-common-profile>&nbsp; &nbsp; &nbsp; &nbsp;​</section><p><span style="font-size: 15px;">1. 实时需求日趋迫切</span></p><p><span style="font-size: 15px;">目前各大公司的产品需求和内部决策对于数据实时性的要求越来越迫切， &nbsp;需要实时数仓的能⼒来赋能 。传统离 线数仓的数据时效性是 T+1，调度频率以天为单位，⽆法⽀撑实时场景的数据需求 。即使能将调度频率设置成 ⼩时，也只能解决部分时效性要求不高的场景，对于实效性要求很高的场景还是⽆法优雅的⽀撑 。因此实时使 用数据的问题必须得到有效解决。</span></p><p><span style="font-size: 15px;">2. 实时技术日趋成熟</span></p><p><span style="font-size: 15px;">实时计算框架已经经历了三代发展，分别是：Storm 、SparkStreaming 、Flink，计算框架越来越成熟。</span></p><p><span style="font-size: 15px;">⼀⽅⾯， &nbsp;实时任务的开发已经能通过编写 SQL 的⽅式来完成，在技术层⾯能很好地继承离线数仓的架构设计 思想；</span></p><p><span style="font-size: 15px;">另⼀⽅⾯ ，在线数据开发平台所提供的功能对实时任务开发 、调试 、运维的⽀持也⽇渐趋于成熟， &nbsp;开发成本逐 步降低，有助于去做这件事。</span></p><p><span style="font-size: 15px;">二、实时数仓建设目的</span></p><p><span style="font-size: 15px;">1. 解决传统数仓的问题</span></p><p><span style="font-size: 15px;">从目前数仓建设的现状来看， &nbsp;实时数仓是⼀个容易让⼈产生混淆的概念，根据传统经验分析，数仓有⼀个重要 的功能， &nbsp;即能够记录历史 。通常，数仓都是希望从业务上线的第⼀天开始有数据，然后⼀直记录到现在。</span></p><p><span style="font-size: 15px;">但实时流处理技术， &nbsp;⼜是强调当前处理状态的⼀个技术，结合当前⼀线大⼚的建设经验和滴滴在该领域的建设 现状，我们尝试把公司内实时数仓建设的目的定位为， &nbsp;以数仓建设理论和实时技术，解决由于当前离线数仓数 据时效性低解决不了的问题。</span></p><p><span style="font-size: 15px;">现阶段我们要建设实时数仓的主要原因是：</span></p><p><span style="font-size: 15px;">公司业务对于数据的实时性越来越迫切， &nbsp;需要有实时数据来辅助完成决策；</span></p><p><span style="font-size: 15px;">实时数据建设没有规范，数据可用性较差，⽆法形成数仓体系， &nbsp;资源大量浪费；</span></p><p><span style="font-size: 15px;">数据平台⼯具对整体实时开发的⽀持也⽇渐趋于成熟， &nbsp;开发成本降低。</span></p><p><span style="font-size: 15px;">2. 实时数仓的应用场景</span></p><p><span style="font-size: 15px;">实时 OLAP 分析；</span></p><p><span style="font-size: 15px;">实时数据看板；</span></p><p><span style="font-size: 15px;">实时业务监控；</span></p><p><span style="font-size: 15px;">实时数据接⼝服务。</span></p><p><span style="font-size: 15px;">三、实时数仓建设方案</span></p><p><span style="font-size: 15px;">接下来我们分析下目前实时数仓建设比较好的⼏个案例，希望这些案例能够给⼤家带来⼀些启发。</span></p><p><strong><span style="font-size: 15px;">1. 滴滴顺风车实时数仓案例</span></strong><span style="font-size: 15px;"></span></p><p><span style="font-size: 15px;">滴滴数据团队建设的实时数仓，基本满足了顺风车业务方在实时侧的各类业务需求，初步建立起顺风车实时数 仓，完成了整体数据分层， &nbsp;包含明细数据和汇总数据，统⼀了 DWD 层， &nbsp;降低了⼤数据资源消耗，提高了数据</span></p><p><span style="font-size: 15px;">复用性，可对外输出丰富的数据服务。</span></p><p><span style="font-size: 15px;">数仓具体架构如下图所示：</span></p><p><img class="rich_pages wxw-img" data-ratio="0.7658321060382917" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0lEyDpHIux5A8Ayj8COKp7Sthlv6CC75QXOMiaMkSPVvAezJnUia0ukJQ/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">从数据架构图来看，顺风车实时数仓和对应的离线数仓有很多类似的地方 。例如分层结构；&nbsp;比如 ODS 层， &nbsp;明 细层，汇总层， &nbsp;乃至应用层，他们命名的模式可能都是⼀样的 。但仔细比较不难发现，两者有很多区别：</span></p><p><span style="font-size: 15px;">与离线数仓相比， &nbsp;实时数仓的层次更少⼀些</span></p><p><span style="font-size: 15px;">从目前建设离线数仓的经验来看，数仓的数据明细层内容会非常丰富，处理明细数据外⼀般还会包含轻度 汇总层的概念， &nbsp;另外离线数仓中应用层数据在数仓内部，但实时数仓中，app 应用层数据已经落⼊应用系 统的存储介质中，可以把该层与数仓的表分离；</span></p><p><span style="font-size: 15px;">应用层少建设的好处：实时处理数据的时候，每建⼀个层次，数据必然会产生⼀定的延迟；</span></p><p><span style="font-size: 15px;">汇总层少建的好处：在汇总统计的时候，往往为了容忍⼀部分数据的延迟，可能会⼈为的制造⼀些延迟来 保证数据的准确 。举例，在统计跨天相关的订单事件中的数据时，可能会等到 00¸00¸05 或者 00¸00¸ 10</span></p><p><span style="font-size: 15px;">再统计，确保 00¸00 前的数据已经全部接受到位了，再进⾏统计 。所以，汇总层的层次太多的话，就会更 大的加重⼈为造成的数据延迟。</span></p><p><span style="font-size: 15px;">与离线数仓相比， &nbsp;实时数仓的数据源存储不同</span></p><p><span style="font-size: 15px;">在建设离线数仓的时候， &nbsp; 目前滴滴内部整个离线数仓都是建⽴在 Hive 表之上 。但是，在建设实时数仓的 时候， &nbsp;同⼀份表，会使用不同的方式进⾏存储 。比如常⻅的情况下， &nbsp;明细数据或者汇总数据都会存在</span></p><p><span style="font-size: 15px;">Kafka 里⾯ ，但是像城市 、渠道等维度信息需要借助 Hbase， &nbsp;mysql 或者其他 KV 存储等数据库来进⾏存 储。</span></p><p><span style="font-size: 15px;">接下来，根据顺⻛车实时数仓架构图，对每⼀层建设做具体展开：</span></p><p><strong><span style="font-size: 15px;">实时数仓分层建设</span></strong><span style="font-size: 15px;"></span></p><p></p><p><span style="font-size: 15px;">1. ODS 贴源层建设</span></p><p><span style="font-size: 15px;">根据顺⻛车具体场景， &nbsp; 目前顺⻛车数据源主要包括订单相关的 binlog 日志， &nbsp;冒泡和安全相关的 public 日志， 流量相关的埋点日志等。</span></p><p><span style="font-size: 15px;">这些数据部分已采集写⼊ kafka 或 ddmq 等数据通道中，部分数据需要借助内部自研同步⼯具完成采集， &nbsp;最终 基于顺⻛车数仓 ods 层建设规范分主题统⼀写⼊ kafka 存储介质中。</span></p><p><span style="font-size: 15px;">命名规范：ODS 层实时数据源主要包括两种。</span></p><p><span style="font-size: 15px;">⼀种是在离线采集时已经自动生产的 DDMQ 或者是 Kafkatopic， &nbsp;这类型的数据命名方式为采集系统自动</span></p><p><span style="font-size: 15px;">生成规范为：cn-binlog-数据库名-数据库名 eg：&nbsp; cn-binlog-ihap_fangyuan-ihap_fangyuan &nbsp;⼀种是需要自⼰进⾏采集同步到 kafkatopic 中，生产的 topic 命名规范同离线类似：ODS 层采 用：&nbsp; realtime_ods_binlog_{源系统库/表名}/ods_log_{日志名} eg:</span></p><p><span style="font-size: 15px;">realtime_ods_binlog_ihap_fangyuan</span></p><p><span style="font-size: 15px;">2. DWD 明细层建设</span></p><p><span style="font-size: 15px;">根据顺⻛车业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细层事实表；结合顺⻛ 车分析师在离线侧的数据使用特点，将明细事实表的某些重要维度属性字段做适当冗余，完成宽表化处理， &nbsp;之 后基于当前顺⻛车业务方对实时数据的需求重点， &nbsp;重点建设交易 、财务 、体验 、安全 、流量等⼏大模块；该层 的数据来源于 ODS 层，通过大数据架构提供的 Stream SQL 完成 ETL ⼯作，对于 binlog 日志的处理主要进⾏ 简单的数据清洗 、处理数据漂移和数据乱序， &nbsp;以及可能对多个 ODS 表进⾏ Stream Join，对于流量日志主要是 做通用的 ETL 处理和针对顺⻛车场景的数据过滤，完成⾮结构化数据的结构化处理和数据的分流；该层的数据 除了存储在消息队列 Kafka 中，通常也会把数据实时写⼊ Druid 数据库中，供查询明细数据和作为简单汇总数 据的加⼯数据源。</span></p><p><span style="font-size: 15px;">命名规范：DWD 层的表命名使用英文⼩写字母， &nbsp;单词之间用下划线分开，总⻓度不能超过 40 个字符，并且应 遵循下述规则：&nbsp; realtime_dwd_{业务/pub}_{数据域缩写}_ [{业务过程缩写}]_ [{自定义表命名标签缩写}]</span></p><p><span style="font-size: 15px;"> &nbsp;{业务/pub}：参考业务命名</span></p><p><span style="font-size: 15px;"> &nbsp;{数据域缩写}：参考数据域划分部分</span></p><p><span style="font-size: 15px;"> &nbsp;{自定义表命名标签缩写}：实体名称可以根据数据仓库转换整合后做⼀定的业务抽象的名称，该名称应该</span></p><p><span style="font-size: 15px;">准确表述实体所代表的业务含义</span></p><p><span style="font-size: 15px;">样例：realtime_dwd_trip_trd_order_base</span></p><p><span style="font-size: 15px;">3. DIM 层</span></p><p><span style="font-size: 15px;">公共维度层，基于维度建模理念思想， &nbsp;建⽴整个业务过程的⼀致性维度， &nbsp;降低数据计算⼝径和算法不统⼀ ⻛险；</span></p><p><span style="font-size: 15px;">DIM 层数据来源于两部分：⼀部分是 Flink 程序实时处理 ODS 层数据得到， &nbsp;另外⼀部分是通过离线任务 出仓得到；</span></p><p><span style="font-size: 15px;">DIM 层维度数据主要使用 MySQL 、Hbase 、fusion(滴滴自研 KV 存储) 三种存储引擎，对于维表数据比较 少的情况可以使用 MySQL，对于单条数据大⼩比较⼩ ，查询 QPS 比较高的情况，可以使用 fusion 存</span></p><p><span style="font-size: 15px;">储， &nbsp;降低机器内存资源占用，对于数据量比较大，对维表数据变化不是特别敏感的场景，可以使用 HBase 存储。</span></p><p><span style="font-size: 15px;">命名规范：DIM 层的表命名使用英⽂⼩写字母， &nbsp;单词之间用下划线分开，总⻓度不能超过 30 个字符，并且应 遵循下述规则：&nbsp; dim_{业务/pub}_{维度定义}[_{自定义命名标签}] ：</span></p><p><span style="font-size: 15px;"> &nbsp;{业务/pub}：参考业务命名</span></p><p><span style="font-size: 15px;"> &nbsp;{维度定义}：参考维度命名</span></p><p><span style="font-size: 15px;"> &nbsp;{自定义表命名标签缩写}：实体名称可以根据数据仓库转换整合后做⼀定的业务抽象的名称，该名称应该</span></p><p><span style="font-size: 15px;">准确表述实体所代表的业务含义</span></p><p><span style="font-size: 15px;">样例：dim_trip_dri_base</span></p><p></p><p><span style="font-size: 15px;">4. DWM 汇总层建设</span></p><p><span style="font-size: 15px;">在建设顺⻛车实时数仓的汇总层的时候，跟顺⻛车离线数仓有很多⼀样的地⽅ ，但其具体技术实现会存在很大 不同。</span></p><p><span style="font-size: 15px;">第⼀：&nbsp;对于⼀些共性指标的加⼯， &nbsp;比如 pv， &nbsp;uv，订单业务过程指标等，我们会在汇总层进⾏统⼀的运算，确 &nbsp;保关于指标的⼝径是统⼀在⼀个固定的模型中完成 。对于⼀些个性指标，从指标复用性的⻆度出发，确定唯⼀ 的时间字段， &nbsp;同时该字段尽可能与其他指标在时间维度上完成拉齐，例如⾏中异常订单数需要与交易域指标在 事件时间上做到拉齐。</span></p><p><span style="font-size: 15px;">第⼆：在顺⻛车汇总层建设中， &nbsp;需要进⾏多维的主题汇总， &nbsp;因为实时数仓本身是⾯向主题的，可能每个主题会 关⼼的维度都不⼀样，所以需要在不同的主题下， &nbsp;按照这个主题关⼼的维度对数据进⾏汇总， &nbsp;最后来算业务⽅ 需要的汇总指标 。在具体操作中，对于 pv 类指标使用 Stream SQL 实现 1 分钟汇总指标作为最⼩汇总单位指 标，在此基础上进⾏时间维度上的指标累加；对于 uv 类指标直接使用druid 数据库作为指标汇总容器，根据 业务⽅对汇总指标的及时性和准确性的要求， &nbsp;实现相应的精确去重和⾮精确去重。</span></p><p><span style="font-size: 15px;">第三：&nbsp;汇总层建设过程中， &nbsp;还会涉及到衍生维度的加⼯ 。在顺⻛车券相关的汇总指标加⼯中我们使用 Hbase 的版本机制来构建⼀个衍生维度的拉链表，通过事件流和 Hbase 维表关联的⽅式得到实时数据当时的准确维 度</span></p><p><span style="font-size: 15px;">命名规范：DWM 层的表命名使用英⽂⼩写字母， &nbsp;单词之间用下划线分开，总⻓度不能超过 40 个字符，并且 应遵循下述规则：&nbsp; realtime_dwm_{业务/pub}_{数据域缩写}_{数据主粒度缩写}_ [{自定义表命名标签缩写}]_{统计时 间周期范围缩写} ：</span></p><p><span style="font-size: 15px;"> &nbsp;{业务/pub}：参考业务命名</span></p><p><span style="font-size: 15px;"> &nbsp;{数据域缩写}：参考数据域划分部分</span></p><p><span style="font-size: 15px;"> &nbsp;{数据主粒度缩写}：指数据主要粒度或数据域的缩写，也是联合主键中的主要维度</span></p><p><span style="font-size: 15px;">{自定义表命名标签缩写}：实体名称可以根据数据仓库转换整合后做⼀定的业务抽象的名称，该名称应该 准确表述实体所代表的业务含义</span></p><p><span style="font-size: 15px;">{统计时间周期范围缩写}：1d:天增量；td:天累计(全量)；1h:小时增量；th:小时累计(全量)；1min:分钟增 量；tmin:分钟累计(全量)</span></p><p><span style="font-size: 15px;">样例：&nbsp; realtime_dwm_trip_trd_pas_bus_accum_1min</span></p><p></p><p><span style="font-size: 15px;">5. APP 应用层</span></p><p><span style="font-size: 15px;">该层主要的工作是把实时汇总数据写⼊应用系统的数据库中， &nbsp;包括用于大屏显示和实时 OLAP 的 Druid 数据库 (该数据库除了写⼊应用数据，也可以写⼊明细数据完成汇总指标的计算)中，用于实时数据接⼝服务的 Hbase 数据库，用于实时数据产品的 mysql 或者 redis 数据库中。</span></p><p><span style="font-size: 15px;">命名规范：基于实时数仓的特殊性不做硬性要求。</span></p><p><span style="font-size: 15px;">顺风车实时数仓建设成果</span></p><p><span style="font-size: 15px;">截止目前，⼀ 共为顺风车业务线建立了增长 、交易 、体验 、安全 、财务五大模块，涉及 40+ 的实时看板，涵盖 顺风车全部核⼼业务过程， &nbsp;实时和离线数据误差&lt;0.5%， &nbsp;是顺风车业务线数据分析⽅面的有利补充，为顺风车 当天发券动态策略调整， &nbsp;司乘安全相关监控， &nbsp;实时订单趋势分析等提供了实时数据⽀持，提高了决策的时效 &nbsp; &nbsp; 性。</span></p><p><span style="font-size: 15px;">同时建立在数仓模型之上的实时指标能根据用户需求及时完成⼝径变更和实时离线数据⼀致性校验，大大提高 了实时指标的开发效率和实时数据的准确性，也为公司内部大范围建设实时数仓提供了有⼒的理论和实践⽀ &nbsp; 持。</span></p><p><strong><span style="font-size: 15px;">2. 快手实时数仓场景化案例</span></strong><span style="font-size: 15px;"></span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0deXqZ8bqYVfBvpeA7TwSy4chQwVibmoAPfLTicZK10syjmiceibGk2C94w/640?wx_fmt=jpeg"  /></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0ZuHCkpZQsmllFYibztV9KrPickmCoXJwpobN44L3YQOBym2BIyYUy8Ww/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">1. 目标</span></p><p><span style="font-size: 15px;">首先由于是做数仓， &nbsp;因此希望所有的实时指标都有离线指标去对应，要求实时指标和离线指标整体的数据 差异在 1% 以内， &nbsp;这是最低标准。</span></p><p><span style="font-size: 15px;">其次是数据延迟，其 SLA 标准是活动期间所有核⼼报表场景的数据延迟不能超过 5 分钟， &nbsp;这 5 分钟包括 作业挂掉之后和恢复时间，如果超过则意味着 SLA 不达标。</span></p><p><span style="font-size: 15px;">最后是稳定性，针对⼀些场景， &nbsp;比如作业重启后，我们的曲线是正常的，不会因为作业重启导致指标产出 ⼀些明显的异常。</span></p><p><span style="font-size: 15px;">2. 难点</span></p><p><span style="font-size: 15px;">第⼀个难点是数据量大 。每天整体的⼊口流量数据量级大概在万亿级 。在活动如春晚的场景， &nbsp;QPS 峰值能 达到亿 / 秒。</span></p><p><span style="font-size: 15px;">第⼆个难点是组件依赖比较复杂 。可能这条链路里有的依赖于 Kafka，有的依赖 Flink， &nbsp;还有⼀些依赖 KV 存储 、RPC 接口 、OLAP 引擎等，我们需要思考在这条链路里如何分布，才能让这些组件都能正常工作。</span></p><p><span style="font-size: 15px;">第三个难点是链路复杂 。目前我们有 200+ 核⼼业务作业， &nbsp;50+ 核⼼数据源，整体作业超过 1000。</span></p><p><span style="font-size: 15px;">2) 实时数仓 - 分层模型</span></p><p><span style="font-size: 15px;">基于上面三个难点，来看⼀下数仓架构：</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0ia0S2Jw2jCzGYzTjiaflBES13gmTMCVB8fWQRh7jkgkFPibkBpHdo35Zg/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">如上所示：</span></p><p><span style="font-size: 15px;"> &nbsp;最下层有三个不同的数据源，分别是客户端日志 、服务端日志以及 Binlog 日志；</span></p><p><span style="font-size: 15px;"> &nbsp;在公共基础层分为两个不同的层次，⼀个是 DWD 层，做明细数据， &nbsp;另⼀个是 DWS 层，做公共聚合数</span></p><p><span style="font-size: 15px;">据， &nbsp;DIM 是我们常说的维度 。我们有⼀个基于离线数仓的主题预分层， &nbsp;这个主题预分层可能包括流量 、用 户 、设备 、视频的生产消费 、风控 、社交等。</span></p><p><span style="font-size: 15px;"> &nbsp;DWD 层的核⼼工作是标准化的清洗；</span></p><p><span style="font-size: 15px;"> &nbsp;DWS 层是把维度的数据和 DWD 层进行关联，关联之后生成⼀些通用粒度的聚合层次。</span></p><p><span style="font-size: 15px;"> &nbsp;再往上是应用层， &nbsp;包括⼀些大盘的数据， &nbsp;多维分析的模型以及业务专题数据；</span></p><p><span style="font-size: 15px;"> &nbsp;最上面是场景。</span></p><p><span style="font-size: 15px;">整体过程可以分为三步：</span></p><p><span style="font-size: 15px;">第⼀步是做业务数据化，相当于把业务的数据接进来；</span></p><p><span style="font-size: 15px;">第⼆步是数据资产化，意思是对数据做很多的清洗，然后形成⼀些规则有序的数据；</span></p><p><span style="font-size: 15px;">第三步是数据业务化，可以理解数据在实时数据层面可以反哺业务，为业务数据价值建设提供⼀些赋能。</span></p><p><span style="font-size: 15px;">3) 实时数仓 - 保障措施</span></p><p><span style="font-size: 15px;">基于上面的分层模型，来看⼀下整体的保障措施：</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0huXK2KZ8heEq9XnC6jwvykGtolibebTQ6wvwdeDNSo8C0qVg0smGjCg/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">保障层面分为三个不同的部分，分别是质量保障， &nbsp;时效保障以及稳定保障。</span></p><p><span style="font-size: 15px;"> &nbsp;我们先看蓝色部分的质量保障 。针对质量保障，可以看到在数据源阶段，做了如数据源的乱序监控， &nbsp;这是</span></p><p><span style="font-size: 15px;">我们基于自⼰的 SDK 的采集做的， &nbsp;以及数据源和离线的⼀致性校准 。研发阶段的计算过程有三个阶段， 分别是研发阶段 、上线阶段和服务阶段。</span></p><p><span style="font-size: 15px;"> &nbsp;研发阶段可能会提供⼀个标准化的模型，基于这个模型会有⼀些 Benchmark，并且做离线的比对验</span></p><p><span style="font-size: 15px;">证，保证质量是⼀致的；</span></p><p><span style="font-size: 15px;"> &nbsp;上线阶段更多的是服务监控和指标监控；</span></p><p><span style="font-size: 15px;"> &nbsp;在服务阶段，如果出现⼀些异常情况，先做 Flink 状态拉起，如果出现了⼀些不符合预期的场景，我</span></p><p><span style="font-size: 15px;">们会做离线的整体数据修复。</span></p><p><span style="font-size: 15px;"> &nbsp;第⼆个是时效性保障 。针对数据源，我们把数据源的延迟情况也纳⼊监控 。在研发阶段其实还有两个事</span></p><p><span style="font-size: 15px;">情：</span></p><p><span style="font-size: 15px;"> &nbsp;首先是压测， &nbsp;常规的任务会拿最近 7 天或者最近 14 天的峰值流量去看它是否存在任务延迟的情况；</span><span style="font-size: 15px;"> &nbsp;通过压测之后，会有⼀些任务上线和重启性能评估，相当于按照 CP 恢复之后， &nbsp;重启的性能是什么样</span></p><p><span style="font-size: 15px;">⼦ 。</span></p><p><span style="font-size: 15px;"> &nbsp;最后⼀个是稳定保障， &nbsp;这在大型活动中会做得比较多， &nbsp;比如切换演练和分级保障 。我们会基于之前的压测</span></p><p><span style="font-size: 15px;">结果做限流， &nbsp; 目的是保障作业在超过极限的情况下， &nbsp;仍然是稳定的，不会出现很多的不稳定或者 CP 失败 的情况 。之后我们会有两种不同的标准，⼀ 种是冷备双机房， &nbsp;另外⼀种是热备双机房。</span></p><p><span style="font-size: 15px;"> &nbsp;冷备双机房是：&nbsp;当⼀个单机房挂掉，我们会从另⼀个机房去拉起；</span></p><p><span style="font-size: 15px;"> &nbsp;热备双机房：相当于同样⼀份逻辑在两个机房各部署⼀次。</span></p><p><span style="font-size: 15px;">以上就是我们整体的保障措施。</span></p><p><span style="font-size: 15px;">4) 快手场景问题及解决方案</span></p><p><span style="font-size: 15px;">1. PV/UV 标准化</span></p><p><span style="font-size: 15px;">1.1 场景</span></p><p><span style="font-size: 15px;">第⼀个问题是 PV/UV 标准化， &nbsp;这里有三个截图：</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd03Qqhtth1FWnibdngEVRoBRjIVKz7Fbjl44sib7tB80rxjiabtIx11RuSg/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">第⼀张图是春晚活动的预热场景，相当于是⼀种玩法，第二和第三张图是春晚当天的发红包活动和直播间截 图。</span></p><p><span style="font-size: 15px;">在活动进行过程中，我们发现 60~70% 的需求是计算页面里的信息，如：</span></p><p><span style="font-size: 15px;">这个页面来了多少人，或者有多少人点击进入这个页面；</span></p><p><span style="font-size: 15px;">活动⼀共来了多少人；</span></p><p><span style="font-size: 15px;">页面里的某⼀个挂件，获得了多少点击 、产生了多少曝光。</span></p><p><span style="font-size: 15px;">1.2 方案</span></p><p><span style="font-size: 15px;">抽象⼀下这个场景就是下面这种 SQL：</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5655375552282769" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0UlUTHUWQByJVdJ9nyZE927DdQYaSQcFFHVjDe0JRxGw3tYZn86kd2A/640?wx_fmt=jpeg"  /></p><p><br  /></p><p><span style="font-size: 15px;">简单来说，就是从⼀张表做筛选条件，然后按照维度层面做聚合，接着产生⼀些 Count 或者 Sum 操作。基于这种场景，我们最开始的解决方案如上图右边所示。</span></p><p><span style="font-size: 15px;">我们用到了 Flink SQL 的 Early Fire 机制，从 Source 数据源取数据， &nbsp;之后做了 DID 的分桶 。比如最开始紫色 的部分按这个做分桶，先做分桶的原因是防止某⼀个 DID 存在热点的问题 。分桶之后会有⼀个叫做 Local &nbsp; &nbsp; &nbsp;Window Agg 的东西，相当于数据分完桶之后把相同类型的数据相加 。Local Window Agg 之后再按照维度进 行 Global Window Agg 的合桶，合桶的概念相当于按照维度计算出最终的结果 。Early Fire 机制相当于在 &nbsp; &nbsp; &nbsp;Local Window Agg 开⼀个天级的窗⼝ ，然后每分钟去对外输出⼀次。</span></p><p><span style="font-size: 15px;">这个过程中我们遇到了⼀些问题，如上图左下角所示。</span></p><p><span style="font-size: 15px;">在代码正常运行的情况下是没有问题的，但如果整体数据存在延迟或者追溯历史数据的情况， &nbsp;比如⼀分钟 &nbsp; &nbsp; &nbsp;Early Fire ⼀次， &nbsp;因为追溯历史的时候数据量会比较大，所以可能导致 14¸00 追溯历史， &nbsp;直接读到了 14¸02 的 数据，而 14¸01 的那个点就被丢掉了，丢掉了以后会发生什么？</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0oJ7WeCCfTEzxLRmia0kDWPIaN7182FVicEXRxYiccstHwETVhBWcxia9RA/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">在这种场景下， &nbsp;图中上方的曲线为 Early Fire 回溯历史数据的结果 。横坐标是分钟，纵坐标是截止到当前时刻 的页面 UV，我们发现有些点是横着的，意味着没有数据结果，然后⼀个陡增，然后⼜横着的，接着⼜⼀个陡 增，而这个曲线的预期结果其实是图中下方那种平滑的曲线。</span></p><p><span style="font-size: 15px;">为了解决这个问题，我们用到了 Cumulate Window 的解决方案， &nbsp;这个解决方案在 Flink 1.13 版本里也有涉 及，其原理是⼀样的。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0wQ98IvYDTjxk5B3veMEOqvt2vgOWqDqYKRa8g9vxDcu4oe2giaBt6ZQ/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">数据开⼀个大的天级窗口，大窗口下又开了⼀个小的分钟级窗口，数据按数据本身的 Row Time 落到分钟级窗 口。</span></p><p><span style="font-size: 15px;">Watermark 推进过了窗口的 event_time， &nbsp;它会进行⼀次下发的触发，通过这种方式可以解决回溯的问 题，数据本身落在真实的窗口， &nbsp; Watermark 推进，在窗口结束后触发。</span></p><p><span style="font-size: 15px;">此外， &nbsp;这种方式在⼀定程度上能够解决乱序的问题 。比如它的乱序数据本身是⼀个不丢弃的状态，会记录 到最新的累计数据。</span></p><p><span style="font-size: 15px;">最后是语义⼀致性， &nbsp;它会基于事件时间，在乱序不严重的情况下， &nbsp;和离线计算出来的结果⼀致性是相当高 的。</span></p><p><span style="font-size: 15px;">2. DAU 计算</span></p><p><span style="font-size: 15px;">2.1 背景介绍</span></p><p><span style="font-size: 15px;">下面介绍⼀下 DAU 计算：</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0TcRxweUDQdoNOHEcn090UR3b6OdxOZWpGiaF88eUewztdicSI36FDE1w/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">我们对于整个大盘的活跃设备 、新增设备和回流设备有比较多的监控。</span></p><p><span style="font-size: 15px;">活跃设备指的是当天来过的设备；</span></p><p><span style="font-size: 15px;">新增设备指的是当天来过且历史没有来过的设备；</span></p><p><span style="font-size: 15px;">回流设备指的是当天来过且 N 天内没有来过的设备。</span></p><p><span style="font-size: 15px;">但是我们计算过程之中可能需要 5~8 个这样不同的 Topic 去计算这⼏个指标。</span></p><p><span style="font-size: 15px;">我们看⼀下离线过程中，逻辑应该怎么算。</span></p><p><span style="font-size: 15px;">首先我们先算活跃设备，把这些合并到⼀起，然后做⼀个维度下的天级别去重，接着再去关联维度表， &nbsp;这个维 度表包括设备的首末次时间，就是截止到昨天设备首次访问和末次访问的时间。</span></p><p><span style="font-size: 15px;">得到这个信息之后，我们就可以进⾏逻辑计算，然后我们会发现新增和回流的设备其实是活跃设备里打的⼀个 ⼦标签 。新增设备就是做了⼀个逻辑处理， &nbsp;回流设备是做了 30 天的逻辑处理，基于这样的解决方案，我们能 否简单地写⼀个 SQL 去解决这个问题？</span></p><p><span style="font-size: 15px;">其实我们最开始是这么做的，但遇到了⼀些问题：</span></p><p><span style="font-size: 15px;">第⼀个问题是：数据源是 6~8 个， &nbsp;而且我们大盘的⼝径经常会做微调，如果是单作业的话，每次微调的过 程之中都要改， &nbsp;单作业的稳定性会非常差；</span></p><p><span style="font-size: 15px;">第⼆个问题是：数据量是万亿级， &nbsp;这会导致两个情况， &nbsp;首先是这个量级的单作业稳定性非常差，其次是实 时关联维表的时候用的 KV 存储，任何⼀个这样的 RPC 服务接⼝ ，都不可能在万亿级数据量的场景下保证 服务稳定性；</span></p><p><span style="font-size: 15px;">第三个问题是：我们对于时延要求比较高，要求时延⼩于⼀分钟 。整个链路要避免批处理，如果出现了⼀ 些任务性能的单点问题，我们还要保证高性能和可扩容。</span></p><p><span style="font-size: 15px;">2.2 技术方案</span></p><p><span style="font-size: 15px;">针对以上问题，介绍⼀下我们是怎么做的：</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0VoTBEe5fSJSFNb85PjiaveS5Fg4Hh1QNxfaDIw8zicaEjyD7icWaOOx2w/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">如上图的例⼦ ，第⼀步是对 A B C 这三个数据源，先按照维度和 DID 做分钟级别去重，分别去重之后得到三个 分钟级别去重的数据源，接着把它们 Union 到⼀起，然后再进行同样的逻辑操作。</span></p><p><span style="font-size: 15px;">这相当于我们数据源的⼊⼝从万亿变到了百亿的级别，分钟级别去重之后再进行⼀个天级别的去重，产生的数 据源就可以从百亿变成了⼏⼗亿的级别。</span></p><p><span style="font-size: 15px;">在⼏⼗亿级别数据量的情况下， &nbsp;我们再去关联数据服务化， &nbsp;这就是⼀种比较可行的状态，相当于去关联用户画 像的 RPC 接⼝ ，得到 RPC 接⼝之后， &nbsp;最终写⼊到了目标 Topic。这个目标 Topic 会导⼊到 OLAP 引擎，供给</span></p><p><span style="font-size: 15px;">多个不同的服务， &nbsp;包括移动版服务，大屏服务，指标看板服务等。</span></p><p><span style="font-size: 15px;">这个⽅案有三个⽅面的优势，分别是稳定性 、时效性和准确性。</span></p><p><span style="font-size: 15px;"> &nbsp;首先是稳定性 。松耦合可以简单理解为当数据源 A 的逻辑和数据源 B 的逻辑需要修改时，可以单独修改。</span></p><p><span style="font-size: 15px;">第⼆是任务可扩容， &nbsp;因为我们把所有逻辑拆分得非常细粒度， &nbsp;当⼀些地⽅出现了如流量问题，不会影响后 面的部分，所以它扩容比较简单， &nbsp;除此之外还有服务化后置和状态可控。</span></p><p><span style="font-size: 15px;">其次是时效性，我们做到毫秒延迟，并且维度丰富，整体上有 20+ 的维度做多维聚合。最后是准确性，我们⽀持数据验证 、实时监控 、模型出⼝统⼀等。</span></p><p><span style="font-size: 15px;">此时我们遇到了另外⼀个问题 - 乱序 。对于上⽅三个不同的作业， &nbsp;每⼀个作业重启至少会有两分钟左右的延 迟，延迟会导致下游的数据源 Union 到⼀起就会有乱序。</span></p><p><span style="font-size: 15px;">2.3 延迟计算⽅案</span></p><p><span style="font-size: 15px;">遇到上面这种有乱序的情况下， &nbsp;我们要怎么处理？</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0n46ENHicSwpUK5via1JXU7w225KbuicypZic9jMOiaLicJnBZ7YwMc3DjJQg/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">我们总共有三种处理方案：</span></p><p><span style="font-size: 15px;"> &nbsp;第⼀种解决方案是用“did + 维度 + 分钟”进行去重，Value 设为“是否来过”。比如同⼀个 did， &nbsp;04:01 来</span></p><p><span style="font-size: 15px;">了⼀条， &nbsp;它会进行结果输出 。同样的， &nbsp;04:02 和 04¸04 也会进行结果输出 。但如果 04：01 再来， &nbsp;它就会 丢弃，但如果 04¸00 来，依旧会进行结果输出。</span></p><p><span style="font-size: 15px;">这个解决方案存在⼀些问题， &nbsp;因为我们按分钟存，存 20 分钟的状态大⼩是存 10 分钟的两倍，到后面这个 状态大⼩有点不太可控， &nbsp;因此我们⼜换了解决方案 2。</span></p><p><span style="font-size: 15px;">第⼆种解决方案，我们的做法会涉及到⼀个假设前提，就是假设不存在数据源乱序的情况 。在这种情况 下， &nbsp;key 存的是“did + 维度”，Value 为“时间戳”， &nbsp;它的更新方式如上图所示。</span></p><p><span style="font-size: 15px;">04¸01 来了⼀条数据， &nbsp;进行结果输出 。04:02 来了⼀条数据，如果是同⼀个 did，那么它会更新时间戳， &nbsp;然后仍然做结果输出 。04：04 也是同样的逻辑，然后将时间戳更新到 04：04，如果后面来了⼀条 04：</span></p><p><span style="font-size: 15px;">01 的数据， &nbsp;它发现时间戳已经更新到 04¸04， &nbsp;它会丢弃这条数据。</span></p><p><span style="font-size: 15px;">这样的做法大幅度减少了本身所需要的⼀些状态，但是对乱序是零容忍，不允许发生任何乱序的情况， &nbsp;由 于我们不好解决这个问题， &nbsp;因此我们⼜想出了解决方案 3。</span></p><p><span style="font-size: 15px;"> &nbsp;方案 3 是在方案 2 时间戳的基础之上， &nbsp;加了⼀个类似于环形缓冲区，在缓冲区之内允许乱序。</span></p><p><span style="font-size: 15px;">比如 04¸01 来了⼀条数据， &nbsp;进行结果输出；04¸02 来了⼀条数据， &nbsp;它会把时间戳更新到 04¸02，并且会记 录同⼀个设备在 04¸01 也来过 。如果 04¸04 再来了⼀条数据，就按照相应的时间差做⼀个位移， &nbsp;最后通 &nbsp;过这样的逻辑去保障它能够容忍⼀定的乱序。</span></p><p><span style="font-size: 15px;">综合来看这三个方案：</span></p><p><span style="font-size: 15px;">方案 1 在容忍 16 分钟乱序的情况下， &nbsp;单作业的状态大⼩在 480G 左右 。这种情况虽然保证了准确性，但 是作业的恢复和稳定性是完全不可控的状态， &nbsp;因此我们还是放弃了这个方案；</span></p><p><span style="font-size: 15px;">方案 2 是 30G 左右的状态大⼩ ，对于乱序 0 容忍，但是数据不准确， &nbsp;由于我们对准确性的要求非常高， 因此也放弃了这个方案；</span></p><p><span style="font-size: 15px;"> &nbsp;方案 3 的状态跟方案 1 相比， &nbsp;它的状态虽然变化了但是增加的不多，而且整体能达到跟方案 1 同样的效</span></p><p><span style="font-size: 15px;">果 。方案 3 容忍乱序的时间是 16 分钟，我们正常更新⼀个作业的话， &nbsp;10 分钟完全足够重启， &nbsp;因此最终选 择了方案 3。</span></p><p><span style="font-size: 15px;">3. 运营场景</span></p><p><span style="font-size: 15px;">3.1 背景介绍</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0wHf0icbQPHep2uqJJy9Xwvn48d7aprCSo6GI9TEib4gOAClibETmE2qvg/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">运营场景可分为四个部分：</span></p><p><span style="font-size: 15px;"> &nbsp;第⼀个是数据大屏支持， &nbsp;包括单直播间的分析数据和大盘的分析数据， &nbsp;需要做到分钟级延迟，更新要求比</span></p><p><span style="font-size: 15px;">较高；</span></p><p><span style="font-size: 15px;"> &nbsp;第⼆个是直播看板支持， &nbsp;直播看板的数据会有特定维度的分析，特定⼈群支持，对维度丰富性要求比较</span></p><p><span style="font-size: 15px;">高；</span></p><p><span style="font-size: 15px;"> &nbsp;第三个是数据策略榜单， &nbsp;这个榜单主要是预测热门作品 、爆款，要求的是⼩时级别的数据，更新要求比较</span></p><p><span style="font-size: 15px;">低；</span></p><p><span style="font-size: 15px;"> &nbsp;第四个是 C 端实时指标展示，查询量比较大，但是查询模式比较固定。</span></p><p><span style="font-size: 15px;">下面进行分析这 4 种不同的状态产生的⼀些不同的场景。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd04ddtiaY4sLB8NdfSJ6sH4HTUYFtC6icfARjSdrzKz4dial9rt7RliaFBRQ/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">前 3 种基本没有什么差别， &nbsp;只是在查询模式上， &nbsp;有的是特定业务场景，有的是通用业务场景。</span></p><p><span style="font-size: 15px;">针对第 3 种和第 4 种， &nbsp;它对于更新的要求比较低，对于吞吐的要求比较高，过程之中的曲线也不要求有⼀致 性 。第 4 种查询模式更多的是单实体的⼀些查询， &nbsp;比如去查询内容，会有哪些指标，而且对 QPS 要求比较 &nbsp;高。</span></p><p><span style="font-size: 15px;">3.2 技术方案</span></p><p><span style="font-size: 15px;">针对上方 4 种不同的场景，我们是如何去做的？</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5640648011782032" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0wtDJTaCnrV6oxrnic8ftGPb2ibdC6SZbpKn3wicwWBkW2MqcpHgJgcaAA/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">首先看⼀下基础明细层 (图中左方)，数据源有两条链路，其中⼀条链路是消费的流， &nbsp;比如直播的消费信 息， &nbsp;还有观看 / 点赞 / 评论 。经过⼀轮基础清洗，然后做维度管理 。上游的这些维度信息来源于 Kafka，</span></p><p><br  /></p><p><span style="font-size: 15px;">Kafka 写⼊了⼀些内容的维度，放到了 KV 存储里边， &nbsp;包括⼀些用户的维度。</span></p><p><span style="font-size: 15px;">这些维度关联了之后， &nbsp;最终写⼊ Kafka 的 DWD 事实层， &nbsp;这里为了做性能的提升，我们做了⼆级缓存的操 作。</span></p><p><span style="font-size: 15px;"> &nbsp;如图中上⽅ ，我们读取 DWD 层的数据然后做基础汇总，核⼼是窗⼝维度聚合生成 4 种不同粒度的数据，</span></p><p><span style="font-size: 15px;">分别是大盘多维汇总 topic 、直播间多维汇总 topic 、作者多维汇总 topic 、用户多维汇总 topic， &nbsp;这些都是 通用维度的数据。</span></p><p><span style="font-size: 15px;"> &nbsp;如图中下⽅ ，基于这些通用维度数据，我们再去加⼯个性化维度的数据，也就是 ADS 层 。拿到了这些数</span></p><p><span style="font-size: 15px;">据之后会有维度扩展， &nbsp;包括内容扩展和运营维度的拓展，然后再去做聚合， &nbsp;比如会有电商实时 topic，机 构服务实时 topic 和大 V 直播实时 topic。</span></p><p><span style="font-size: 15px;">分成这样的两个链路会有⼀个好处：⼀个地⽅处理的是通用维度， &nbsp;另⼀个地⽅处理的是个性化的维度 。通 用维度保障的要求会比较高⼀些，个性化维度则会做很多个性化的逻辑 。如果这两个耦合在⼀起的话，会 发现任务经常出问题，并且分不清楚哪个任务的职责是什么，构建不出这样的⼀个稳定层。</span></p><p><span style="font-size: 15px;">如图中右⽅， &nbsp;最终我们用到了三种不同的引擎 。简单来说就是 Redis 查询用到了 C 端的场景， &nbsp;OLAP 查询 用到了大屏 、业务看板的场景。</span></p><p><span style="font-size: 15px;">5) 未来规划</span></p><p><span style="font-size: 15px;">上⽂⼀共讲了三个场景，第⼀个场景是标准化 PU/UV 的计算，第⼆个场景是 DAU 整体的解决⽅案，第三个场 景是运营侧如何解决 。基于这些内容，我们有⼀些未来规划，分为 4 个部分。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0PNX8kZicmJJf5ZA3ricSaXyEiaY0GsEaBGU69FsibibiaJhnSvVYfefQHT8A/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;"> &nbsp;第⼀部分是实时保障体系完善：</span></p><p><span style="font-size: 15px;"> &nbsp;⼀⽅面做⼀些大型的活动， &nbsp;包括春晚活动以及后续常态化的活动 。针对这些活动如何去保障，我们有</span></p><p><span style="font-size: 15px;">⼀套规范去做平台化的建设；</span></p><p><span style="font-size: 15px;"> &nbsp;第⼆个是分级保障标准制定， &nbsp;哪些作业是什么样的保障级别 / 标准，会有⼀个标准化的说明；</span></p><p><span style="font-size: 15px;"> &nbsp;第三个是引擎平台能⼒推动解决， &nbsp;包括 Flink 任务的⼀些引擎，在这上面我们会有⼀个平台，基于这</span></p><p><span style="font-size: 15px;">个平台去做规范 、标准化的推动。</span></p><p><span style="font-size: 15px;"> &nbsp;第⼆部分是实时数仓内容构建：</span></p><p><span style="font-size: 15px;"> &nbsp;⼀⽅面是场景化⽅案的输出， &nbsp;比如针对活动会有⼀些通用化的⽅案，而不是每次活动都开发⼀套新的</span></p><p><span style="font-size: 15px;">解决⽅案；</span></p><p><span style="font-size: 15px;"> &nbsp;另⼀⽅面是内容数据层次沉淀， &nbsp;比如现在的数据内容建设，在厚度⽅面有⼀些场景的缺失， &nbsp;包括内容</span></p><p><span style="font-size: 15px;">如何更好地服务于上游的场景。</span></p><p><span style="font-size: 15px;">第三部分是 Flink SQL 场景化构建， &nbsp;包括 SQL 持续推⼴ 、SQL 任务稳定性和 SQL 任务资源利用率 。我们 在预估资源的过程中，会考虑比如在什么样 QPS 的场景下， &nbsp; SQL 用什么样的解决⽅案，能⽀撑到什么情</span></p><p><span style="font-size: 15px;">况 。Flink SQL 可以⼤幅减少⼈效，但是在这个过程中，我们想让业务操作更加简单。</span></p><p><span style="font-size: 15px;">第四部分是批流⼀体探索 。实时数仓的场景其实就是做离线 ETL 计算加速，我们会有很多⼩时级别的任</span></p><p><span style="font-size: 15px;">务，针对这些任务，每次批处理的时候有⼀些逻辑可以放到流处理去解决， &nbsp;这对于离线数仓 SLA 体系的提 升⼗分巨⼤ 。</span></p><p><span style="font-size: 15px;">3. 腾讯看点实时数仓案例</span></p><p><span style="font-size: 15px;">腾讯看点业务为什么要构建实时数仓？&nbsp;因为原始的上报数据量非常⼤，⼀ 天上报峰值就有上万亿条 。而且上报 格式混乱 。缺乏内容维度信息 、用户画像信息，下游没办法直接使用。</span></p><p><span style="font-size: 15px;">而我们提供的实时数仓， &nbsp;是根据腾讯看点信息流的业务场景， &nbsp;进行了内容维度的关联，用户画像的关联，各种 粒度的聚合，下游可以非常⽅便的使用实时数据，而且实时数据仓库可以提供给下游的用户反复的消费使用， 可以⼤量的减少重复的⼯作。</span></p><p><span style="font-size: 15px;">1) 方案选型</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5625920471281296" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd03Mxed6AvKiaeUVRyUF8AM4t5COFVoiaVbOnPkhUTEg1lYA0PUhe51rbQ/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">那就看下我们多维实时数据分析系统的⽅案选型，选型我们对比了行业内的领先⽅案，选择了最符合我们业务 场景的⽅案。</span></p><p><span style="font-size: 15px;"> &nbsp;第⼀块是实时数仓的选型，我们选择的是业界比较成熟的 Lambda 架构，他的优点是灵活性高 、容错性</span></p><p><span style="font-size: 15px;">高 、成熟度高和迁移成本低；缺点是实时 、离线数据用两套代码，可能会存在⼀个⼝径修改了， &nbsp;另⼀个没 改的问题，我们每天都有做数据对账的⼯作，如果有异常会进行告警。</span></p><p><br  /></p><p><span style="font-size: 15px;">第⼆块是实时计算引擎选型， &nbsp;因为 Flink 设计之初就是为了流处理，SparkStreaming 严格来说还是微批处 理，Strom 用的已经不多了 。再看 Flink 具有 Exactly-once 的准确性 、轻量级 Checkpoint 容错机制 、低</span></p><p><span style="font-size: 15px;">延时高吞吐和易用性高的特点，我们选择了 Flink 作为实时计算引擎。</span></p><p><span style="font-size: 15px;">第三块是实时存储引擎，我们的要求就是需要有维度索引 、支持高并发 、预聚合 、高性能实时多维 OLAP</span></p><p><span style="font-size: 15px;">查询 。可以看到， &nbsp;Hbase 、Tdsql 和 ES 都不能满足要求， &nbsp;Druid 有⼀个缺陷， &nbsp;它是按照时序划分 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment，无法将同⼀个内容，存放在同⼀个 Segment 上， &nbsp;计算全局 TopN 只能是近似值，所以我们选 择了最近两年大火的 MPP 数据库引擎 ClickHouse。</span></p><p><span style="font-size: 15px;">2) 设计目标与设计难点</span></p><p><img class="rich_pages wxw-img" data-ratio="0.4580265095729013" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0rfwC29mFHBRb3ZDRUQDezeoAdBxVzDc29VIQ8LgqIlfdon1WPlVPBw/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">我们多维实时数据分析系统分为三大模块</span></p><p><span style="font-size: 15px;">1. 实时计算引擎</span></p><p><span style="font-size: 15px;">2. 实时存储引擎</span></p><p><span style="font-size: 15px;">3. App 层</span></p><p><span style="font-size: 15px;">难点主要在前两个模块：实时计算引擎和实时存储引擎。</span></p><p><span style="font-size: 15px;">1. 千万级/s 的海量数据如何实时接⼊ ，并且进行极低延迟维表关联。</span></p><p><span style="font-size: 15px;">2. 实时存储引擎如何支持高并发写⼊ 、高可用分布式和高性能索引查询， &nbsp;是比较难的。这⼏个模块的具体实现，看⼀下我们系统的架构设计。</span></p><p><span style="font-size: 15px;">3) 架构设计</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5066273932253313" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd03VG9IMlSASEGLd0mof3XbHAd3iamTDMUPeQR5eSoeibgY9RtHibQgVOKw/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">前端采用的是开源组件 Ant Design，利用了 Nginx 服务器，部署静态页面，并反向代理了浏览器的请求到后 台服务器上。</span></p><p><span style="font-size: 15px;">后台服务是基于腾讯自研的 RPC 后台服务框架写的，并且会进⾏⼀些⼆级缓存。</span></p><p><span style="font-size: 15px;">实时数仓部分，分为了接⼊层 、实时计算层和实时数仓存储层。</span></p><p><span style="font-size: 15px;">接⼊层主要是从千万级/s 的原始消息队列中，拆分出不同⾏为数据的微队列，拿看点的视频来说，拆分过 后，数据就只有百万级/s 了；</span></p><p><span style="font-size: 15px;">实时计算层主要负责， &nbsp;多⾏⾏为流水数据进⾏⾏转列， &nbsp;实时关联用户画像数据和内容维度数据；</span></p><p><span style="font-size: 15px;">实时数仓存储层主要是设计出符合看点业务的，下游好用的实时消息队列 。我们暂时提供了两个消息队</span></p><p><span style="font-size: 15px;">列，作为实时数仓的两层 。⼀层 DWM 层是内容 ID-用户 ID 粒度聚合的，就是⼀条数据包含内容 ID-用户 ID 还有 B 侧内容数据 、C 侧用户数据和用户画像数据；另⼀层是 DWS 层， &nbsp;是内容 ID 粒度聚合的，⼀ 条 数据包含内容 ID， &nbsp;B 侧数据和 C 侧数据 。可以看到内容 ID-用户 ID 粒度的消息队列流量进⼀步减小到⼗ 万级/s， &nbsp;内容 ID 粒度的更是万级/s，并且格式更加清晰，维度信息更加丰富。</span></p><p><span style="font-size: 15px;">实时存储部分分为实时写⼊层 、OLAP 存储层和后台接⼝层。</span></p><p><span style="font-size: 15px;">实时写⼊层主要是负责 Hash 路由将数据写⼊；</span></p><p><span style="font-size: 15px;">OLAP 存储层利用 MPP 存储引擎，设计符合业务的索引和物化视图， &nbsp;高效存储海量数据；后台接⼝层提供高效的多维实时查询接⼝ 。</span></p><p><span style="font-size: 15px;">4) 实时计算</span></p><p><span style="font-size: 15px;">这个系统最复杂的两块， &nbsp;实时计算和实时存储。</span></p><p><span style="font-size: 15px;">先介绍实时计算部分：分为实时关联和实时数仓。</span></p><p><span style="font-size: 15px;">1. 实时高性能维表关联</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.49042709867452133" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0dlOicGicHMp5q5IRg9SYqrb4cJvkliaMGxC1vjh7BWDYWxeb3PDYHGHSw/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">实时维表关联这⼀块难度在于 百万级/s 的实时数据流，如果直接去关联 HBase， &nbsp;1 分钟的数据，关联完 HBase 耗时是⼩时级的，会导致数据延迟严重。</span></p><p><span style="font-size: 15px;">我们提出了⼏个解决方案：</span></p><p><span style="font-size: 15px;">第⼀个是，在 Flink 实时计算环节，先按照 1 分钟进行了窗⼝聚合，将窗⼝内多行行为数据转⼀行多列的 数据格式，经过这⼀步操作，原本⼩时级的关联耗时下降到了⼗⼏分钟，但是还是不够的。</span></p><p><span style="font-size: 15px;">第二个是，在访问 HBase 内容之前设置⼀层 Redis 缓存， &nbsp;因为 1000 条数据访问 HBase 是秒级的，而访</span></p><p><span style="font-size: 15px;">问 Redis 是毫秒级的，访问 Redis 的速度基本是访问 HBase 的 1000 倍 。为了防止过期的数据浪费缓 &nbsp; &nbsp; 存，缓存过期时间设置成 24 ⼩时， &nbsp;同时通过监听写 HBase Proxy 来保证缓存的⼀致性 。这样将访问时间</span></p><p><span style="font-size: 15px;">从⼗⼏分钟变成了秒级。</span></p><p><span style="font-size: 15px;">第三个是，上报过程中会上报不少非常规内容 ID， &nbsp;这些内容 ID 在内容 HBase 中是不存储的，会造成缓存</span></p><p><span style="font-size: 15px;">穿透的问题 。所以在实时计算的时候，我们直接过滤掉这些内容 ID， &nbsp;防止缓存穿透， &nbsp;⼜减少⼀些时间 。&nbsp; 第四个是， &nbsp;因为设置了定时缓存，会引⼊⼀个缓存雪崩的问题 。为了防止雪崩，我们在实时计算中， &nbsp;进行</span></p><p><span style="font-size: 15px;">了削峰填谷的操作，错开设置缓存的时间。</span></p><p><span style="font-size: 15px;">可以看到，优化前后，数据量从百亿级减少到了⼗亿级，耗时从⼩t时级减少到了数⼗秒，减少 99%。</span></p><p><span style="font-size: 15px;">2. 下游提供服务</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5066273932253313" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0iaHISY2SR6wicAqIJl0icqacRBibnxqXV9AuN0gBg1bQu1A4oMPMBzRJXQ/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">实时数仓的难度在于：它处于比较新的领域，并且各个公司各个业务差距比较大，怎么能设计出⽅便，好用， 符合看点业务场景的实时数仓是有难度的。</span></p><p><span style="font-size: 15px;">先看⼀下实时数仓做了什么， &nbsp;实时数仓对外就是⼏个消息队列，不同的消息队列里面存放的就是不同聚合粒度 的实时数据， &nbsp;包括内容 ID 、用户 ID 、C 侧行为数据 、B 侧内容维度数据和用户画像数据等。</span></p><p><span style="font-size: 15px;">我们是怎么搭建实时数仓的，就是上面介绍的实时计算引擎的输出，放到消息队列中保存，可以提供给下游多 用户复用。</span></p><p><span style="font-size: 15px;">我们可以看下， &nbsp;在我们建设实时数据仓库前后， &nbsp;开发⼀个实时应用的区别 。没有数仓的时候，我们需要消费千 万级/s 的原始队列， &nbsp;进行复杂的数据清洗，然后再进行用户画像关联 、内容维度关联，才能拿到符合要求格式 的实时数据， &nbsp;开发和扩展的成本都会比较高，如果想开发⼀个新的应用， &nbsp;⼜要走⼀遍这个流程 。有了数仓之 &nbsp; 后，如果想开发内容 ID 粒度的实时应用，就直接申请 TPS 万级/s 的 DWS 层的消息队列 。开发成本变低很 &nbsp; &nbsp;多， &nbsp;资源消耗⼩很多，可扩展性也强很多。</span></p><p><span style="font-size: 15px;">看个实际例⼦， &nbsp;开发我们系统的实时数据大屏，原本需要进行如上所有操作，才能拿到数据 。现在只需要消费 DWS 层消息队列， &nbsp;写⼀条 Flink SQL 即可，仅消耗 2 个 CPU 核⼼， &nbsp;1G 内存。</span></p><p><span style="font-size: 15px;">可以看到， &nbsp;以 50 个消费者为例， &nbsp;建立实时数仓前后，下游开发⼀个实时应用，可以减少 98%的资源消耗 。包 括计算资源，存储资源，⼈⼒成本和开发⼈员学习接⼊成本等等 。并且消费者越多， &nbsp;节省越多 。就拿 Redis 存 储这⼀部分来说，⼀个⽉就能省下上百万⼈民币。</span></p><p><span style="font-size: 15px;">5) 实时存储</span></p><p><span style="font-size: 15px;">介绍完实时计算，再来介绍实时存储。</span></p><p><span style="font-size: 15px;">这块分为三个部分来介绍</span></p><p><span style="font-size: 15px;">第⼀是 分布式-高可用</span></p><p><span style="font-size: 15px;">第⼆是 海量数据-写⼊</span></p><p><span style="font-size: 15px;">第三是 高性能-查询</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.3784977908689249" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0h4ea8S8pU3FQyerU22tRE67Al3h7NS64teIRicMfv9H7JWibXdb8dDSw/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">我们这里听取的是 Clickhouse 官方的建议，借助 ZK 实现高可用的方案 。数据写⼊⼀个分片，仅写⼊⼀个副 本，然后再写 ZK，通过 ZK 告诉同⼀个分片的其他副本，其他副本再过来拉取数据，保证数据⼀致性。</span></p><p><span style="font-size: 15px;">这里没有选用消息队列进⾏数据同步， &nbsp;是因为 ZK 更加轻量级 。而且写的时候，任意写⼀个副本，其它副本都 能够通过 ZK 获得⼀致的数据 。而且就算其它节点第⼀次来获取数据失败了，后⾯只要发现它跟 ZK 上记录的 数据不⼀致，就会再次尝试获取数据，保证⼀致性。</span></p><p><span style="font-size: 15px;">2. 海量数据-写入</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5095729013254786" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0mbv3JowHbYU5C82XXLwlf87iaeyechOuIYicOJRMZibPfUUOaiczzZDZDA/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">数据写⼊遇到的第⼀个问题是，海量数据直接写⼊ Clickhouse 的话，会导致 ZK 的 QPS 太高，解决方案是改 用 Batch 方式写⼊ 。Batch 设置多大呢， &nbsp;Batch 太⼩的话缓解不了 ZK 的压⼒ ， &nbsp;Batch 也不能太大，不然上游 内存压⼒太大，通过实验， &nbsp;最终我们选用了大⼩⼏⼗万的 Batch。</span></p><p><span style="font-size: 15px;">第⼆个问题是， &nbsp;随着数据量的增⻓， &nbsp;单 QQ 看点的视频内容每天可能写⼊百亿级的数据，默认方案是写⼀张分 布式表， &nbsp;这就会造成单台机器出现磁盘的瓶颈，尤其是 Clickhouse 底层运用的是 Mergetree，原理类似于 &nbsp; &nbsp; HBase 、RocketsDB 的底层 LSM-Tree。在合并的过程中会存在写放大的问题，加重磁盘压⼒ 。峰值每分钟⼏ 千万条数据， &nbsp;写完耗时⼏⼗秒，如果正在做 Merge，就会阻塞写⼊请求，查询也会⾮常慢 。我们做的两个优化 方案：⼀是对磁盘做 Raid，提升磁盘的 IO；⼆是在写⼊之前进⾏分表， &nbsp;直接分开写⼊到不同的分片上， &nbsp;磁盘 &nbsp;压⼒直接变为 1/N。</span></p><p><br  /></p><p><span style="font-size: 15px;">第三个问题是，虽然我们写⼊按照分片进⾏了划分，但是这里引⼊了⼀个分布式系统常⻅的问题，就是局部的 Top 并非全局 Top 的问题 。比如同⼀个内容 ID 的数据落在了不同的分片上， &nbsp;计算全局 Top100 阅读的内容 &nbsp; &nbsp;ID，有⼀个内容 ID 在分片 1 上是 Top100，但是在其它分片上不是 Top100，导致汇总的时候，会丢失⼀部分 数据，影响最终结果 。我们做的优化是在写⼊之前加上⼀层路由，将同⼀个内容 ID 的记录，全部路由到同⼀ &nbsp;个分片上， &nbsp;解决了该问题。</span></p><p><span style="font-size: 15px;">介绍完写⼊，下⼀步介绍 Clickhouse 的高性能存储和查询。</span></p><p><span style="font-size: 15px;">3. 高性能-存储-查询</span></p><p><span style="font-size: 15px;">Clickhouse 高性能查询的⼀个关键点是稀疏索引 。稀疏索引这个设计就很有讲究，设计得好可以加速查询，设 计不好反而会影响查询效率 。我根据我们的业务场景， &nbsp;因为我们的查询大部分都是时间和内容 ID 相关的， &nbsp;比 &nbsp; 如说，某个内容，过去 N 分钟在各个⼈群表现如何？我按照⽇期，分钟粒度时间和内容 ID 建立了稀疏索引 。&nbsp;针对某个内容的查询， &nbsp;建立稀疏索引之后，可以减少 99%的⽂件扫描。</span></p><p><span style="font-size: 15px;">还有⼀个问题就是，我们现在数据量太大，维度太多 。拿 QQ 看点的视频内容来说，⼀ 天流水有上百亿条，有 些维度有⼏百个类别 。如果⼀次性把所有维度进⾏预聚合，数据量会指数膨胀，查询反而变慢，并且会占用大 量内存空间 。我们的优化，针对不同的维度， &nbsp;建立对应的预聚合物化视图，用空间换时间， &nbsp;这样可以缩短查询 的时间。</span></p><p><span style="font-size: 15px;">腾讯看点高性能存储</span></p><p><img class="rich_pages wxw-img" data-ratio="0.3858615611192931" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0C5yBpTBeQMDmaprhsmDz8G9HcCia1yJ591d4Q2ZYNibMb2tg29zHbBDA/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">分布式表查询还会有⼀个问题，查询单个内容 ID 的信息，分布式表会将查询下发到所有的分片上， &nbsp;然后再返 &nbsp;回查询结果进⾏汇总 。实际上， &nbsp;因为做过路由，⼀个内容 ID 只存在于⼀个分片上， &nbsp;剩下的分片都在空跑 。针 &nbsp;对这类查询，我们的优化是后台按照同样的规则先进⾏路由， &nbsp;直接查询目标分片， &nbsp;这样减少了 N-1/N 的负载， 可以大量缩短查询时间 。而且由于我们是提供的 OLAP 查询，数据满足最终⼀致性即可，通过主从副本读写分 离，可以进⼀步提升性能。</span></p><p><span style="font-size: 15px;">我们在后台还做了⼀个 1 分钟的数据缓存，针对相同条件查询，后台就直接返回了。</span></p><p><span style="font-size: 15px;">4. 扩容</span></p><p><span style="font-size: 15px;">这里再介绍⼀下我们的扩容的⽅案，调研了业内的⼀些常⻅⽅案。</span></p><p><span style="font-size: 15px;">比如 HBase，原始数据都存放在 HDFS 上， &nbsp;扩容只是 Region Server 扩容，不涉及原始数据的迁移 。但是 Clickhouse 的每个分片数据都是在本地， &nbsp;是⼀个比较底层存储引擎，不能像 HBase 那样⽅便扩容。</span></p><p><br  /></p><p><span style="font-size: 15px;">Redis 是哈希槽这种类似⼀致性哈希的方式， &nbsp;是比较经典分布式缓存的方案 。Redis slot 在 Rehash 的过程中 虽然存在短暂的 ask 读不可用，但是总体来说迁移是比较方便的，从原 h[0]迁移到 h[1]， &nbsp;最后再删除 h[0]。但是 Clickhouse ⼤部分都是 OLAP 批量查询，不是点查，而且由于列式存储，不支持删除的特性，⼀ 致性哈 希的方案不是很适合。</span></p><p><span style="font-size: 15px;">目前扩容的方案是， &nbsp;另外消费⼀份数据， &nbsp;写⼊新 Clickhouse 集群，两个集群⼀起跑⼀段时间， &nbsp;因为实时数据 就保存 3 天，等 3 天之后，后台服务直接访问新集群。</span></p><p><span style="font-size: 15px;">4. 有赞实时数仓案例</span></p><p><span style="font-size: 15px;">1) 分层设计</span></p><p><span style="font-size: 15px;">传统离线数仓的分层设计⼤家都很熟悉，为了规范的组织和管理数据，层级划分会比较多，在⼀些复杂逻辑处 理场景还会引⼊临时层落地中间结果以方便下游加⼯处理 。实时数仓考虑到时效性问题，分层设计需要尽量精</span></p><p><span style="font-size: 15px;">简， &nbsp;降低中间流程出错的可能性，不过总体而⾔， &nbsp;实时数仓还是会参考离线数仓的分层思想来设计。</span></p><p><span style="font-size: 15px;">实时数仓分层架构如下图所示 ：</span></p><p><img class="rich_pages wxw-img" data-ratio="0.6686303387334315" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0yumAzUu2Ufnk6tmEVRtkEvdg9DuYGDahAN3KlUUvyaR10XGFeuEWRA/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;"> &nbsp;ODS &nbsp;( 实时数据接入层)</span></p><p><span style="font-size: 15px;">ODS 层， &nbsp;即实时数据接⼊层，通过数据采集⼯具收集各个业务系统的实时数据，对非结构化的数据进⾏结构化 处理，保存原始数据，⼏乎不过滤数据；该层数据的主要来源有三个部分：第⼀部分是业务方创建的 NSQ 消 &nbsp;息，第⼆部分是业务数据库的 Binlog 日志，第三部分是埋点日志和应用程序日志， &nbsp;以上三部分的实时数据最终 统⼀写⼊ Kafka 存储介质中。</span></p><p><span style="font-size: 15px;">ODS 层表命名规范：部门名称.应用名称.数仓层级主题域前缀数据库名/消息名</span></p><p><br  /></p><p><span style="font-size: 15px;">例如：接⼊业务库的 Binlog</span></p><p><span style="font-size: 15px;">实时数仓表命名：&nbsp; deptname.appname.ods_subjectname_tablename</span></p><p><span style="font-size: 15px;">例如：接⼊业务方的 NSQ 消息</span></p><p><span style="font-size: 15px;">实时数仓表命名：&nbsp; deptname.appname.ods_subjectname_msgname</span></p><p><span style="font-size: 15px;"> &nbsp;DWS &nbsp;( 实时明细中间层)</span></p><p><span style="font-size: 15px;">DWS 层， &nbsp;即实时明细中间层，该层以业务过程作为建模驱动，基于每个具体的业务过程事件来构建最细粒度 的明细层事实表；&nbsp;比如交易过程，有下单事件 、支付事件 、发货事件等，我们会基于这些独立的事件来进行明 细层的构建 。在这层，事实明细数据同样是按照离线数仓的主题域来进行划分，也会采用维度建模的方式组织 数据，对于⼀些重要的维度字段，会做适当冗余 。基于有赞实时需求的场景， &nbsp;重点建设交易 、营销 、客户 、店 铺 、商品等主题域的数据 。该层的数据来源于 ODS 层，通过 FlinkSQL 进行 ETL 处理， &nbsp;主要⼯作有规范命 &nbsp; &nbsp; 名 、数据清洗 、维度补全 、多流关联， &nbsp;最终统⼀写⼊ Kafka 存储介质中。</span></p><p><span style="font-size: 15px;">DWS 层表命名规范：&nbsp; 部门名称 .应用名称 .数仓层级_主题域前缀_数仓表命名</span></p><p><span style="font-size: 15px;">例如：实时事件 A 的中间层</span></p><p><span style="font-size: 15px;">实时数仓表命名：&nbsp; deptname.appname.dws_subjectname_tablename_eventnameA</span></p><p><span style="font-size: 15px;">例如：实时事件 B 的中间层</span></p><p><span style="font-size: 15px;">实时数仓表命名：&nbsp; deptname.appname.dws_subjectname_tablename_eventnameB</span></p><p><span style="font-size: 15px;"> &nbsp;DIM &nbsp;( 实时维表层)</span></p><p><span style="font-size: 15px;">DIM 层， &nbsp;即实时维表层，用来存放维度数据， &nbsp;主要用于实时明细中间层宽化处理时补全维度使用， &nbsp; 目前该层的 数据主要存储于 HBase 中，后续会基于 QPS 和数据量大⼩提供更多合适类型的存储介质。</span></p><p><span style="font-size: 15px;">DIM 层表命名规范：&nbsp; 应用名称_数仓层级_主题域前缀_数仓表命名</span></p><p><span style="font-size: 15px;">例如：HBase 存储， &nbsp;实时维度表</span></p><p><span style="font-size: 15px;">实时数仓表命名：&nbsp; appname_dim_tablename</span></p><p><span style="font-size: 15px;"> &nbsp;DWA &nbsp;( 实时汇总层)</span></p><p><span style="font-size: 15px;">DWA 层， &nbsp;即实时汇总层，该层通过 DWS 层数据进行多维汇总，提供给下游业务方使用，在实际应用过程中， 不同业务方使用维度汇总的方式不太⼀样，根据不同的需求采用不同的技术方案去实现 。第⼀种方式，采用 &nbsp; &nbsp;FlinkSQL 进行实时汇总，将结果指标存⼊ HBase 、MySQL 等数据库，该种方式是我们早期采用的方案，优点 是实现业务逻辑比较灵活，缺点是聚合粒度固化，不易扩展；第⼆种方式，采用实时 OLAP ⼯具进行汇总，该 种方式是我们目前常用的方案，优点是聚合粒度易扩展，缺点是业务逻辑需要在中间层预处理。</span></p><p><span style="font-size: 15px;">DWA 层表命名规范：&nbsp; 应用名称_数仓层级_主题域前缀_聚合粒度_数据范围</span></p><p><span style="font-size: 15px;">例如：HBase 存储，某域当日某粒度实时汇总表</span></p><p><span style="font-size: 15px;">实时数仓表命名：&nbsp; appname_dwa_subjectname_aggname_daily</span></p><p><span style="font-size: 15px;"> &nbsp;APP &nbsp;( 实时应用层)</span></p><p><span style="font-size: 15px;">APP 层， &nbsp;即实时应用层，该层数据已经写入应用系统的存储中，例如写入 Druid 作为 BI 看板的实时数据集；写入 HBase 、MySQL 用于提供统⼀数据服务接口；写入 ClickHouse 用于提供实时 OLAP 服务 。因为该层非 常贴近业务，在命名规范上实时数仓不做统⼀要求。</span></p><p><span style="font-size: 15px;">2) 实时 ETr</span></p><p><span style="font-size: 15px;">实时数仓 ETL 处理过程所涉及的组件比较多，接下来盘点构建实时数仓所需要的组件以及每个组件的应用场 景 。如下图所示：</span></p><p><img class="rich_pages wxw-img" data-ratio="0.4992636229749632" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0MPXH5Xk4xMbXejWLBhCENmibF4Fmvg7gHriawCmJElMicBtQfQHnewm9g/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">具体实时 ETL 处理流程如下图所示：</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.9027982326951399" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0UepO0vU4RrX2jSicdN0do5TDoxQk7DIldVRwRiaGq4zmzia5slu93PWicg/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">1. 维度补全</span></p><p><span style="font-size: 15px;">创建调用 Duboo 接口的 UDF 函数在实时流里补全维度是最便捷的使用方式，但如果请求量过大，对 Duboo &nbsp;接口压力会过大 。在实际应用场景补全维度首选还是关联维度表，但关联也存在⼀定概率的丢失问题，为了弥 补这种丢失，可以采用 Duboo 接口调用兜底的方式来补全 。伪代码如下：</span></p><p><span style="font-size: 15px;">create function call_dubbo as 'XXXXXXX';</span></p><p><span style="font-size: 15px;">create function get_json_object as 'XXXXXXX';</span></p><p><span style="font-size: 15px;">case</span></p><p><span style="font-size: 15px;">when cast( b.column as bigint) is not null</span></p><p><span style="font-size: 15px;">then cast( b.column as bigint)</span></p><p><span style="font-size: 15px;">else cast(coalesce(cast(get_json_object(call_dubbo( 'clusterUrl '</span></p><p><span style="font-size: 15px;">, 'serviceName '</span></p><p><span style="font-size: 15px;">, 'methodName '</span></p><p><span style="font-size: 15px;">,cast(concat( ' [ ',cast(a.column as varchar), '] ') as varchar)</span></p><p><span style="font-size: 15px;">, 'key '</span></p><p><span style="font-size: 15px;">)</span></p><p><span style="font-size: 15px;">, 'rootId ')</span></p><p><span style="font-size: 15px;">as bigint)</span></p><p><br  /></p><p><span style="font-size: 15px;">,a.column)</span></p><p><span style="font-size: 15px;">as bigint) &nbsp;end</span></p><p><span style="font-size: 15px;">2. 幕等处理</span></p><p><span style="font-size: 15px;">实时任务在运⾏过程中难免会遇到执⾏异常的情况， &nbsp;当任务异常重启的时候会导致部分消息重新发送和消费， 从而引发下游实时统计数据不准确，为了有效避免这种情况，可以选择对实时消息流做幂等处理， &nbsp;当消费完⼀ 条消息，将这条消息的 Key 存⼊ KV，如果任务异常重启导致消息重新发送的时候，先从 KV 判断该消息是否 已被消费，如果已消费就不再往下发送 。伪代码如下：</span></p><p><span style="font-size: 15px;">create function idempotenc as 'XXXXXXX';</span></p><p><span style="font-size: 15px;">insert into table</span></p><p><span style="font-size: 15px;">select</span></p><p><span style="font-size: 15px;">order_no</span></p><p><span style="font-size: 15px;">from</span></p><p><span style="font-size: 15px;">(</span></p><p><span style="font-size: 15px;">select</span></p><p><span style="font-size: 15px;">a.orderNo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;as &nbsp;order_no</span></p><p><span style="font-size: 15px;">, idempotenc( 'XXXXXXX', coalesce( order_no, ' ') ) &nbsp;as &nbsp;rid</span></p><p><span style="font-size: 15px;">from</span></p><p><span style="font-size: 15px;">table1</span></p><p><span style="font-size: 15px;">) t</span></p><p><span style="font-size: 15px;">where</span></p><p><span style="font-size: 15px;">t.rid = 0;</span></p><p><span style="font-size: 15px;">3. 数据验证</span></p><p><span style="font-size: 15px;">由于实时数仓的数据是⽆边界的流，相比于离线数仓固定不变的数据更难验收 。基于不同的场景，我们提供了 2 种验证⽅式，分别是：抽样验证与全量验证 。如下图所示</span></p><p><span style="font-size: 15px;"> &nbsp;抽样验证⽅案</span></p><p><span style="font-size: 15px;">该⽅案主要应用在数据准确性验证上， &nbsp;实时汇总结果是基于存储在 Kafka 的实时明细中间层计算而来，但 &nbsp; &nbsp; &nbsp; Kafka 本身不⽀持按照特定条件检索，不⽀持写查询语句，再加上消息的⽆边界性，统计结果是在不断变化 &nbsp; &nbsp;的，很难寻找参照物进⾏比对 。鉴于此，我们采用了持久化消息的⽅法，将消息落盘到 TiDB 存储，基于 TiDB 的能⼒对落盘的消息进⾏检索 、查询 、汇总 。编写固定时间边界的测试用例与相同时间边界的业务库数据或者 离线数仓数据进⾏比对 。通过以上⽅式，抽样核⼼店铺的数据进⾏指标准确性验证，确保测试用例全部通过。</span></p><p><span style="font-size: 15px;"> &nbsp;全量验证⽅案</span></p><p><span style="font-size: 15px;">该⽅案主要应用在数据完整性和⼀致性验证上， &nbsp;在实时维度表验证的场景使用最多 。大体思路：将存储实时维 度表的在线 HBase 集群中的数据同步到离线 HBase 集群中，再将离线 HBase 集群中的数据导⼊到 Hive 中， 在限定实时维度表的时间边界后，通过数据平台提供的数据校验功能， &nbsp;比对实时维度表与离线维度表是否存在 差异， &nbsp;最终确保两张表的数据完全⼀致。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.28865979381443296" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0Mgr1JicMiccY9j2OFeBAXHZxGD7MPalibNiaxkqCHZurz2gvWKD7XqNq7A/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">4. 数据恢复</span></p><p><span style="font-size: 15px;">实时任务⼀旦上线就要求持续不断的提供准确 、稳定的服务 。区别于离线任务按天调度，如果离线任务出现 &nbsp; Bug，会有充足的时间去修复 。如果实时任务出现 Bug，必须按照提前制定好的流程，严格按照步骤执行，否 则极易出现问题 。造成 Bug 的情况有非常多， &nbsp;比如代码 Bug 、异常数据 Bug 、实时集群 Bug，如下图展示了 修复实时任务 Bug 并恢复数据的流程。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.49337260677466865" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0czl58brCu4oy6dI6icGaMG9neYg0piaSPk3RP0ZStTwygPdM7QJOmZNg/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">5. 腾讯全场景实时数仓建设案例</span></p><p><span style="font-size: 15px;">在数仓体系中会有各种各样的大数据组件，譬如 Hive/HBase/HDFS/S3，计算引擎如 MapReduce 、Spark 、 &nbsp;Flink，根据不同的需求，用户会构建大数据存储和处理平台，数据在平台经过处理和分析，结果数据会保存到 MySQL 、Elasticsearch 等支持快速查询的关系型 、非关系型数据库中，接下来应用层就可以基于这些数据进 行 BI 报表开发 、用户画像，或基于 Presto 这种 OLAP 工具进行交互式查询等。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5301914580265096" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0kS7BmVkPYPgDLJhiaByVUQtyjWTJ8ITPWoph16MQJ4tnf6kXMrOSrvQ/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">1) Lambda 架构的痛点</span></p><p><span style="font-size: 15px;">在整个过程中我们常常会用⼀些离线的调度系统，定期的 &nbsp;( T+1 或者每隔⼏⼩时) &nbsp;去执行⼀些 Spark 分析任 &nbsp; &nbsp;务，做⼀些数据的输⼊ 、输出或是 ETL ⼯作 。离线数据处理的整个过程中必然存在数据延迟的现象，不管是数 据接⼊还是中间的分析，数据的延迟都是比较大的，可能是⼩时级也有可能是天级别的 。另外⼀些场景中我们 也常常会为了⼀些实时性的需求去构建⼀个实时处理过程， &nbsp;比如借助 Flink+Kafka 去构建实时的流处理系统。</span></p><p><span style="font-size: 15px;">整体上， &nbsp;数仓架构中有非常多的组件，大大增加了整个架构的复杂性和运维的成本。</span></p><p><span style="font-size: 15px;">如下图， &nbsp;这是很多公司之前或者现在正在采用的 Lambda 架构， &nbsp;Lambda 架构将数仓分为离线层和实时层，相 应的就有批处理和流处理两个相互独立的数据处理流程， &nbsp;同⼀份数据会被处理两次以上， &nbsp;同⼀套业务逻辑代码 需要适配性的开发两次 。Lambda 架构大家应该已经非常熟悉了，下面我就着重介绍⼀下我们采用 Lambda 架 构在数仓建设过程中遇到的⼀些痛点问题。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5169366715758469" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0adc4aCeDYQPov6F8kq1rmibAKw8rehYM0mibqPaeUQph8qn8KhicVm3sQ/640?wx_fmt=png"  /></p><p><br  /></p><p><span style="font-size: 15px;">例如在实时计算⼀些用户相关指标的实时场景下， &nbsp;我们想看到当前 pv 、uv 时，我们会将这些数据放到实时层 去做⼀些计算， &nbsp;这些指标的值就会实时呈现出来，但同时想了解用户的⼀个增⻓趋势， &nbsp;需要把过去⼀天的数据 计算出来 。这样就需要通过批处理的调度任务来实现， &nbsp;比如凌晨两三点的时候在调度系统上起⼀个 Spark 调度 任务把当天所有的数据重新跑⼀遍。</span></p><p><span style="font-size: 15px;">很显然在这个过程中， &nbsp;由于两个过程运⾏的时间是不⼀样的，跑的数据却相同， &nbsp;因此可能造成数据的不⼀致 。因为某⼀条或⼏条数据的更新， &nbsp;需要重新跑⼀遍整个离线分析的链路，数据更新成本很⼤， &nbsp;同时需要维护离线 和实时分析两套计算平台，整个上下两层的开发流程和运维成本其实都是⾮常高的。</span></p><p><span style="font-size: 15px;">为了解决 Lambda 架构带来的各种问题，就诞生了 Kappa 架构， &nbsp;这个架构⼤家应该也⾮常的熟悉。</span></p><p><span style="font-size: 15px;">2) Kappa 架构的痛点</span></p><p><span style="font-size: 15px;">我们来讲⼀下 Kappa 架构，如下图， &nbsp;它中间其实用的是消息队列，通过用 Flink 将整个链路串联起来 。Kappa 架构解决了 Lambda 架构中离线处理层和实时处理层之间由于引擎不⼀样，导致的运维成本和开发成本高昂的 问题，但 Kappa 架构也有其痛点。</span></p><p><span style="font-size: 15px;"> &nbsp;首先，在构建实时业务场景时，会用到 Kappa 去构建⼀个近实时的场景，但如果想对数仓中间层例如</span></p><p><span style="font-size: 15px;">ODS 层做⼀些简单的 OLAP 分析或者进⼀步的数据处理时，如将数据写到 DWD 层的 Kafka，则需要另外 接⼊ Flink。同时， &nbsp;当需要从 DWD 层的 Kafka 把数据再导⼊到 Clickhouse， &nbsp;Elasticsearch， &nbsp;MySQL 或 &nbsp;者是 Hive 里⾯做进⼀步的分析时， &nbsp;显然就增加了整个架构的复杂性。</span></p><p><span style="font-size: 15px;"> &nbsp;其次， &nbsp;Kappa 架构是强烈依赖消息队列的，我们知道消息队列本身在整个链路上数据计算的准确性是严格</span></p><p><span style="font-size: 15px;">依赖它上游数据的顺序，消息队列接的越多，发生乱序的可能性就越⼤ 。ODS 层数据⼀般是绝对准确的， 把 ODS 层的数据发送到下⼀个 kafka 的时候就有可能发生乱序， &nbsp;DWD 层再发到 DWS 的时候可能⼜乱序 了， &nbsp;这样数据不⼀致性就会变得很严重。</span></p><p><span style="font-size: 15px;">第三， &nbsp;Kafka 由于它是⼀个顺序存储的系统，顺序存储系统是没有办法直接在其上⾯利用 OLAP 分析的⼀ 些优化策略，例如谓词下推这类的优化策略，在顺序存储的 Kafka 上来实现是比较困难的事情。</span></p><p><span style="font-size: 15px;">那么有没有这样⼀个架构， &nbsp;既能够满足实时性的需求， &nbsp;⼜能够满足离线计算的要求，而且还能够减轻运维开发 的成本，解决通过消息队列构建 Kappa 架构过程中遇到的⼀些痛点？答案是肯定的，后⾯的篇幅会详细论 &nbsp; &nbsp; 述。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5213549337260678" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0Qch4KewDQiamZ2CmlXL5KWF1lPViaIqo67mbvQyHIRy6hCsF2lQJyWwA/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">3) 痛点总结</span></p><p><span style="font-size: 15px;">传统 T+1 任务</span></p><p><span style="font-size: 15px;"> &nbsp;海量的TB级 T+ 1 任务延迟导致下游数据产出时间不稳定。</span></p><p><span style="font-size: 15px;"> &nbsp;任务遇到故障重试恢复代价昂贵</span></p><p><span style="font-size: 15px;"> &nbsp;数据架构在处理去重和 exactly-once语义能⼒⽅面比较吃⼒</span></p><p><span style="font-size: 15px;"> &nbsp;架构复杂，涉及多个系统协调， &nbsp;靠调度系统来构建任务依赖关系</span></p><p><span style="font-size: 15px;">Lambda 架构痛点</span></p><p><span style="font-size: 15px;"> &nbsp;同时维护实时平台和离线平台两套引擎， &nbsp;运维成本高</span></p><p><span style="font-size: 15px;"> &nbsp;实时离线两个平台需要维护两套框架不同但业务逻辑相同代码， &nbsp;开发成本高</span></p><p><span style="font-size: 15px;"> &nbsp;数据有两条不同链路，容易造成数据的不⼀致性</span></p><p><span style="font-size: 15px;"> &nbsp;数据更新成本大， &nbsp;需要重跑链路</span></p><p><span style="font-size: 15px;">Kappa 架构痛点</span></p><p><span style="font-size: 15px;"> &nbsp;对消息队列存储要求高，消息队列的回溯能⼒不及离线存储</span></p><p><span style="font-size: 15px;"> &nbsp;消息队列本身对数据存储有时效性，且当前⽆法使用 OLAP 引擎直接分析消息队列中的数据 </span><span style="font-size: 15px;"> &nbsp;全链路依赖消息队列的实时计算可能因为数据的时序性导致结果不正确</span></p><p><span style="font-size: 15px;">4)实时数仓建设需求</span></p><p><span style="font-size: 15px;">是否存在⼀种存储技术， &nbsp;既能够⽀持数据高效的回溯能⼒ ，⽀持数据的更新， &nbsp;⼜能够实现数据的批流读写，并 且还能够实现分钟级到秒级的数据接⼊？</span></p><p><span style="font-size: 15px;">这也是实时数仓建设的迫切需求 。实际上是可以通过对 Kappa 架构进行升级， &nbsp;以解决 Kappa 架构中遇到的⼀ 些问题，接下来主要分享当前比较火的数据湖技术--Iceberg。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5184094256259205" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0LxBEhQ0b4alWRhfw5kfA4MPL65yE2BIMeVHtnayKypoL2gl86A31pg/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">5) 数据湖 Apache Iceberg 的介绍</span></p><p><span style="font-size: 15px;">1.Iceberg 是什么</span></p><p><span style="font-size: 15px;">首先介绍⼀下什么是 Iceberg。官网描述如下：</span></p><p><span style="font-size: 15px;">Apache Iceberg is an open table format for huge analytic datasets. Iceberg adds tables to Presto and Spark that use a high-performance format that works just like a SQL table.</span></p><p><span style="font-size: 15px;">Iceberg 的官方定义是⼀种表格式，可以简单理解为是基于计算层 &nbsp;( Flink , Spark) &nbsp;和存储层 &nbsp;( ORC， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Parqurt，Avro) &nbsp;的⼀个中间层，用 Flink 或者 Spark 将数据写入 Iceberg，然后再通过其他方式来读取这个 表， &nbsp;比如 Spark， &nbsp;Flink， &nbsp;Presto 等。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5301914580265096" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0hwnxjqpFgcVvj3gyxjEwdNmsuadxueicz4ic6RTMWDCFlwjvy4oC0yeA/640?wx_fmt=jpeg"  /></p><p><br  /></p><p><span style="font-size: 15px;">Iceberg 是为分析海量数据准备的，被定义为 table format，table format 介于计算层和存储层之间。</span></p><p><span style="font-size: 15px;">tableformat 主要用于向下管理在存储系统上的⽂件， &nbsp;向上为计算层提供⼀些接⼝ 。存储系统上的⽂件存储都 会采用⼀定的组织形式，譬如读⼀张 Hive 表的时候， &nbsp;HDFS ⽂件系统会带⼀些 partition，数据存储格式 、数 &nbsp;据压缩格式 、数据存储 HDFS 目录的信息等， &nbsp;这些信息都存在 Metastore 上， &nbsp;Metastore 就可以称之为⼀种⽂ 件组织格式。</span></p><p><span style="font-size: 15px;">⼀个优秀的⽂件组织格式，如 Iceberg，可以更高效的⽀持上层的计算层访问磁盘上的⽂件，做⼀些 list、 rename 或者查找等操作。</span></p><p><span style="font-size: 15px;">3.Iceberg 的能力总结</span></p><p><span style="font-size: 15px;">Iceberg 目前⽀持三种⽂件格式 parquet，Avro， &nbsp;ORC，⽆论是 HDFS 或者 S3 上的⽂件，可以看到有⾏存也 有列存，后面会详细的去介绍其作用 。Iceberg 本身具备的能⼒总结如下， &nbsp;这些能⼒对于后面我们利用 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Iceberg 来构建实时数仓是非常重要的。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5110456553755522" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0jibQCMxYjpZabombaadFjMdeQAnpuyzo9J0tf3jt9al6G4XVRxAjULQ/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">4.Iceberg 的文件组织格式介绍</span></p><p><span style="font-size: 15px;">下图展示的是 Iceberg 的整个⽂件组织格式 。从上往下看：</span></p><p><span style="font-size: 15px;">首先最上层是 snapshot 模块 。Iceberg 里面的 snapshot 是⼀个用户可读取的基本的数据单位，也就是说 用户每次读取⼀张表里面的所有数据，都是⼀个snapshot 下的数据。</span></p><p><span style="font-size: 15px;">其次， &nbsp;manifest。⼀个 snapshot 下面会有多个 manifest，如图 snapshot-0 有两个 manifest，而 snapshot-1 有三个 manifest，每个 manifest 下面会管理⼀个至多个 DataFiles ⽂件。</span></p><p><span style="font-size: 15px;">第三， &nbsp;DataFiles。manifest ⽂件里面存放的就是数据的元信息，我们可以打开 manifest ⽂件，可以看到 里面其实是⼀⾏⾏的 datafiles ⽂件路径。</span></p><p><span style="font-size: 15px;">从图上看到，snapshot-1 包含了 snapshop-0 的数据，而 snapshot-1 这个时刻写⼊的数据只有 manifest2， 这个能⼒其实就为我们后面去做增量读取提供了⼀个很好的⽀持。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5346097201767305" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd03HoibibnqZq9If1bxic1hCPRsAP4j82flLUWuUDLcw2uM3ARaQZqTzhicg/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">5.Iceberg 读写过程介绍</span></p><p><span style="font-size: 15px;"> &nbsp;Apache Iceberg 读写</span></p><p><span style="font-size: 15px;">首先，如果有⼀个 write 操作，在写 snapsho-1 的时候，snapshot-1 是虚线框，也就是说此时还没有发生 commit 操作 。这时候对 snapshot-1 的读其实是不可读的， &nbsp;因为用户的读只能读到已经 commit 之后的 &nbsp; &nbsp;snapshot。发生 commit 之后才可以读 。同理，会有 snapshot-2，snapshot-3。</span></p><p><span style="font-size: 15px;">Iceberg 提供的⼀个重要能力，就是读写分离能力 。在对 snapshot-4 进行写的时候，其实是完全不影响对 snapshot-2 和 snapshot-3 的读 。Iceberg 的这个能力对于构建实时数仓是非常重要的能力之⼀ 。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5301914580265096" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0W284S1LjOppYIOeKmxnglyv0h15onQGIsV7WpicDhjVgmWDOck9P83A/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">同理，读也是可以并发的，可以同时读 s1 、s2 、s3 的快照数据， &nbsp;这就提供了回溯读到 snapshot-2 或者 &nbsp; &nbsp; &nbsp; &nbsp; snapshot-3 数据的能力 。Snapshot-4 写完成之后，会发生⼀次 commit 操作， &nbsp;这个时候 snapshot-4 变成了</span></p><p><span style="font-size: 15px;">实心，此时就可以读了 。另外，可以看到 current Snapshot 的指针移到 s4，也就是说默认情况下， &nbsp;用户对⼀ 张表的读操作，都是读 current Snapshot 指针所指向的 Snapshot，但不会影响前面的 snapshot 的读操作。</span></p><p><span style="font-size: 15px;"> &nbsp;Apache Iceberg 增量读</span></p><p><span style="font-size: 15px;">接下来讲⼀下 Iceberg 的增量读 。首先我们知道 Iceberg 的读操作只能基于已经提交完成的 snapshot-1，此 &nbsp;时会有⼀个 snapshot-2，可以看到每个 snapshot 都包含前面 snapshot 的所有数据，如果每次都读全量的数 据，整个链路上对计算引擎来说，读取的代价非常高。</span></p><p><span style="font-size: 15px;">如果只希望读到当前时刻新增的数据， &nbsp;这个时候其实就可以根据 Iceberg 的 snapshot 的回溯机制，仅读取 snapshot1 到 snapshot2 的增量数据，也就是紫色这块的数据可以读的。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5346097201767305" data-type="jpeg" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0kuYBTFukVeDyfibqCb3GYOu4vxEG5TD2F8gOGBqPicIsgiavHloGEPZHw/640?wx_fmt=jpeg"  /></p><p><span style="font-size: 15px;">同理 s3 也是可以只读黄色的这块区域的数据， &nbsp;同时也可以读 s3 到 s1 这块的增量数据，基于 Flink source 的 streaming reader 功能在内部我们已经实现这种增量读取的功能，并且已经在线上运行了 。刚才讲到了⼀个非 常重要的问题， &nbsp;既然 Iceberg 已经有了读写分离，并发读，增量读的功能， &nbsp;Iceberg 要跟 Flink 实现对接，那 &nbsp;么就必须实现 Iceberg 的 sink。</span></p><p><span style="font-size: 15px;"> &nbsp;实时小文件问题</span></p><p><span style="font-size: 15px;">社区现在已经重构了 Flink 里面的 FlinkIcebergSink，提供了 global committee 的功能，我们的架构其实跟社 区的架构是保持⼀致的， &nbsp;曲线框中的这块内容是 FlinkIcebergSink。</span></p><p><span style="font-size: 15px;">在有多个 IcebergStreamWriter 和⼀个 IcebergFileCommitter 的情况下，上游的数据写到 IcebergStreamWriter 的时候，每个 writer 里面做的事情都是去写 datafiles ⽂件。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5508100147275405" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0TmicoqL7kxVvcp1mpHY7VrfXdcwndUzzxAVgearKwvaoTZicCgCHUabA/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">当每个 writer 写完自己当前这⼀批 datafiles 小文件的时候，就会发送消息给 IcebergmileCommitter，告诉它 可以提交了 。而 IcebergmileCommitter 收到信息的时，就⼀次性将 datafiles 的文件提交， &nbsp;进行⼀次 commit 操作。</span></p><p><span style="font-size: 15px;">commit 操作本身只是对⼀些原始信息的修改， &nbsp;当数据都已经写到磁盘了， &nbsp;只是让其从不可见变成可见 。在这 个情况下， &nbsp;Iceberg 只需要用⼀个 commit 即可完成数据从不可见变成可见的过程。</span></p><p><span style="font-size: 15px;"> &nbsp;实时小文件合并</span></p><p><span style="font-size: 15px;">mlink 实时作业⼀般会长期在集群中运行，为了要保证数据的时效性，⼀ 般会把 Iceberg commit 操作的时间周 期设成 30 秒或者是⼀分钟 。当 mlink 作业跑⼀天时，如果是⼀分钟⼀次 commit，⼀ 天需要 1440 个 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;commit，如果 mlink 作业跑⼀个月commit 操作会更多 。甚至 snapshot commit 的时间间隔越短，生成的 &nbsp; &nbsp; &nbsp;snapshot 的数量会越多 。当流式作业运行后，就会生成大量的小文件。</span></p><p><span style="font-size: 15px;">这个问题如果不解决的话， &nbsp;Iceberg 在 mlink 处理引擎上的 sink 操作就不可用了 。我们在内部实现了⼀个叫做 data compaction operator 的功能， &nbsp;这个 operator 是跟着 mlink sink ⼀起走的 。当 Iceberg 的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mlinkIcebergSink 每完成⼀次 commit 操作的时候， &nbsp;它都会向下游 mileScanTaskGen 发送消息，告诉 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mileScanTaskGen 已经完成了⼀次 commit。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5539143279172821" data-type="png" data-w="677" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0SBEjkLNFXu5T8yIdhIEFjY9MWO3JDOibzIzicbJsMnK3GiatKfcVzEKTw/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">FileScanTaskGen 里面会有相关的逻辑，能够根据用户的配置或者当前磁盘的特性来进⾏文件合并任务的生成 操作 。FileScanTaskGen 发送到 DataFileRewitre 的内容其实就是在 FileScanTaskGen 里面生成的需要合并的 文件的列表 。同理， &nbsp;因为合并文件是需要⼀定的耗时操作，所以需要将其进⾏异步的操作分发到不同的task &nbsp; rewrite operator 中。</span></p><p><span style="font-size: 15px;">上面讲过的 Iceberg 是有 commit 操作，对于 rewrite 之后的文件需要有⼀个新的 snapshot 。这里对 Iceberg 来说，也是⼀个 commit 操作，所以采用⼀个单并发的像 commit 操作⼀样的事件。</span></p><p><span style="font-size: 15px;">整条链路下来，小文件的合并目前采用的是 commit 操作，如果 commit 操作后面阻塞了，会影响前面的写⼊ 操作， &nbsp;这块我们后面会持续优化。</span></p><p><span style="font-size: 15px;">6) Flink+Iceberg 构建实时数仓</span></p><p><span style="font-size: 15px;">1.近实时的数据接入</span></p><p><span style="font-size: 15px;">前面介绍了 Iceberg 既支持读写分离， &nbsp;又支持并发读 、增量读 、小文件合并， &nbsp;还可以支持秒级到分钟级的延 迟，基于这些优势我们尝试采用 Iceberg 这些功能来构建基于 Flink 的实时全链路批流⼀体化的实时数仓架 构。</span></p><p><span style="font-size: 15px;">如下图所示， &nbsp;Iceberg 每次的 commit 操作，都是对数据的可⻅性的改变， &nbsp;比如说让数据从不可⻅变成可⻅， 在这个过程中，就可以实现近实时的数据记录。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5508100147275405" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0xHT2ccaIibsibvticvasBDG3lbbcaMniciciblumbfR5e7PRJ4LwoOD4xdoA/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">2.实时数仓 - 数据湖分析系统</span></p><p><span style="font-size: 15px;">此前需要先进行数据接⼊， &nbsp;比如用 Spark 的离线调度任务去跑⼀些数据，拉取，抽取最后再写⼊到 Hive 表里 面， &nbsp;这个过程的延时比较大 。有了 Iceberg 的表结构，可以中间使用 Flink，或者 spark streaming，完成近实 时的数据接⼊ 。</span></p><p><span style="font-size: 15px;">基于以上功能，我们再来回顾⼀下前面讨论的 Kappa 架构， &nbsp;Kappa 架构的痛点上面已经描述过， &nbsp;Iceberg 既然 能够作为⼀个优秀的表格式， &nbsp;既支持 Streaming reader， &nbsp;又可以支持 Streaming sink， &nbsp;是否可以考虑将 Kafka 替换成 Iceberg？</span></p><p><span style="font-size: 15px;">Iceberg 底层依赖的存储是像 HDFS 或 S3 这样的廉价存储，而且 Iceberg 是支持 parquet 、orc 、Avro 这样的 列式存储 。有列式存储的支持，就可以对 OLAP 分析进行基本的优化，在中间层直接进行计算 。例如谓词下推 最基本的 OLAP 优化策略，基于 Iceberg snapshot 的 Streaming reader 功能，可以把离线任务天级别到小时 级别的延迟大大的降低， &nbsp;改造成⼀个近实时的数据湖分析系统。</span></p><p><br  /></p><p><img class="rich_pages wxw-img" data-ratio="0.5272459499263623" data-type="png" data-w="679" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd00MfNVmYT7dM0RV8jCY1rQSTgXQgmQZ5fXD7o2aFsmoVpRL8jyKdkeA/640?wx_fmt=png"  /></p><p><span style="font-size: 15px;">在中间处理层，可以用 presto 进行⼀些简单的查询， &nbsp;因为 Iceberg 支持 Streaming read，所以在系统的中间 层也可以直接接⼊ mlink， &nbsp;直接在中间层用 mlink 做⼀些批处理或者流式计算的任务，把中间结果做进⼀步计算 后输出到下游。</span></p><p><span style="font-size: 15px;"> &nbsp;替换 Kafka 的优劣势：</span></p><p><span style="font-size: 15px;">总的来说，Iceberg 替换 Kafka 的优势主要包括：</span></p><p><span style="font-size: 15px;">实现存储层的流批统⼀</span></p><p><span style="font-size: 15px;">中间层支持 OLAP 分析</span></p><p><span style="font-size: 15px;">完美支持高效回溯</span></p><p><span style="font-size: 15px;">存储成本降低</span></p><p><span style="font-size: 15px;">当然，也存在⼀定的缺陷，如：</span></p><p><span style="font-size: 15px;"> &nbsp;数据延迟从实时变成近实时</span></p><p><span style="font-size: 15px;"> &nbsp;对接其他数据系统需要额外开发工作</span></p><p><span style="font-size: 15px;"> &nbsp;秒级分析 - 数据湖加速：</span></p><p><span style="font-size: 15px;">由于 Iceberg 本身是将数据文件全部存储在 工DmS 上的， &nbsp;工DmS 读写这块对于秒级分析的场景， &nbsp;还是不能够完 全满足我们的需求，所以接下去我们会在 Iceberg 底层支持 Alluxio 这样⼀个缓存，借助于缓存的能⼒可以实 现数据湖的加速 。这块的架构也在我们未来的⼀个规划和建设中。</span></p><p><img class="rich_pages wxw-img" data-ratio="0.5588673621460507" data-type="jpeg" data-w="671" style="height: auto !important;" src="https://mmbiz.qpic.cn/mmbiz_jpg/hXibVSNciaXhylSXhWvyxYGs4LWdLBRDd0XdqHOUwichnicdU8zBZsic52qjpBvz1ejictHJhydoicMib2pM1aK5ra41Fg/640?wx_fmt=jpeg"  /></p><section><mp-common-profile class="custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-weuitheme="light" data-id="MzA3NjIzNjMwOA==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/hXibVSNciaXhzia07WkYkDfaRxHUiaDaNc5x3xTNO1RlNBRhPnxpEzoemhsn7ofat4pVwVgOktaveEtu6IKzzLONQQ/0?wx_fmt=png" data-nickname="数据治理体系" data-alias="DGsystem" data-signature="持续完善数据治理实战体系，数据仓库、标签、数字体系，实现业务数字化，数字资产化，资产业务化，资产资本化；回归业务场景的数字化案例才最具参考价值，最容易理解和借鉴的。" data-from="0" data-weui-theme="light"></mp-common-profile>&nbsp; &nbsp; &nbsp;​</section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></content>
</div>
</body>
</html>